<!-- Search file for "CHANGE" for my own changes -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dapper.mods.LorenzIII API documentation</title>
<meta name="description" content="A multi-scale, smooth version of the classic Lorenz-96 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo.png">
<!-- Dont work coz pdoc already defines these:
<title>DAPPER doc</title>
<meta name="description" content="Data Assimilation with Python: a Package for Experimental Research" />
-->
<a href="https://github.com/nansencenter/DAPPER" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dapper.mods.LorenzIII</code></h1>
</header>
<section id="section-intro">
<p>A multi-scale, smooth version of the classic Lorenz-96.</p>
<p>This is an implementation of "Model III" of <code><a title="bib.lorenz2005designing" href="../../../bib.html#bib.lorenz2005designing">lorenz2005designing</a></code>.</p>
<p>Similar to <code><a title="dapper.mods.LorenzUV" href="../LorenzUV/index.html">dapper.mods.LorenzUV</a></code> this model is designed
to contain two different scales. However, in "Model III"
the two scales are not kept separate, but superimposed,
and the large scale variables are (adjustably) spatially smooth.</p>
<p>Interestingly, the model is known as "Lorenz 04" in DART, where it was
coded by Hansen (colleague of Lorenz) in 2004 (prior to publication).</p>
<p>Special cases of this model are:</p>
<ul>
<li>Set <code>J=1</code> to get "Model II".</li>
<li>Set <code>K=1</code> (and <code>J=1</code>) to get "Model I",
which is the same as the Lorenz-96 model.</li>
</ul>
<p>An implementation using explicit for-loops can be found in commit 6193532b .
It uses numba (pip install required) for speed gain, but is still very slow.
The implementation hereunder uses efficient numpy vectorization =&gt; much faster.</p>
<p>With rk4 the largest stable time step (for free run) seems to be
somewhere around what Lorenz used, namely <code>dt=0.05/12</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L1-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;A multi-scale, smooth version of the classic Lorenz-96.

This is an implementation of &#34;Model III&#34; of `bib.lorenz2005designing`.

Similar to `dapper.mods.LorenzUV` this model is designed
to contain two different scales. However, in &#34;Model III&#34;
the two scales are not kept separate, but superimposed,
and the large scale variables are (adjustably) spatially smooth.

Interestingly, the model is known as &#34;Lorenz 04&#34; in DART, where it was
coded by Hansen (colleague of Lorenz) in 2004 (prior to publication).

Special cases of this model are:

- Set `J=1` to get &#34;Model II&#34;.
- Set `K=1` (and `J=1`) to get &#34;Model I&#34;,
  which is the same as the Lorenz-96 model.

An implementation using explicit for-loops can be found in commit 6193532b .
It uses numba (pip install required) for speed gain, but is still very slow.
The implementation hereunder uses efficient numpy vectorization =&gt; much faster.

With rk4 the largest stable time step (for free run) seems to be
somewhere around what Lorenz used, namely `dt=0.05/12`.
&#34;&#34;&#34;
from dataclasses import dataclass

import numpy as np
from scipy.ndimage import convolve1d

from dapper.mods.integration import rk4


@dataclass
class Model:
    &#34;&#34;&#34;The model configuration.

    Functionality that does not directly depend on the model parameters
    has been left outside of this class.

    Using OOP (rather than module-level encapsulation) facilitates
    working with multiple parameter settings simultaneously.
    &#34;&#34;&#34;
    M    : int   = 960  # state vector length
    J    : int   = 12   # decomposition kernel radius (width/2)
    K    : int   = 32   # smoothing kernel width (increase for +smooth and -waves)
    b    : float = 10   # scaling of small-scale variability
    c    : float = 2.5  # coupling strength
    Force: float = 15   # forcing

    mp   : bool  = False

    def __post_init__(self):
        J = self.J
        self.alpha = (3*J**2 + 3) / (2*J**3 + 4*J)
        self.beta  = (2*J**2 + 1) / (J**4 + 2*J**2)

        # Heuristic
        self.x0 = 2.8*np.ones(self.M)
        self.x0[0] += 0.1*self.Force

    def decompose(self, z):
        &#34;&#34;&#34;Split `z` into `x` and `y` fields, where `x` is the large-scale component.&#34;&#34;&#34;
        width = 2*self.J  # not +1 coz the sum in Lorenz eqn 13a is never ordinary
        _, weights, inds0 = summation_kernel(width)
        weights *= self.alpha - self.beta*abs(inds0)
        x = convolve1d(z, weights, mode=&#34;wrap&#34;)
        # Manual implementation:
        # x = np.zeros_like(z)
        # for m in range(M):
        #     for i, w in zip(inds0, weights):
        #         x[..., m] += w * z[..., mod(m + i)]
        y = z - x
        return x, y

    def dxdt(self, z):
        x, y = self.decompose(z)

        return (
            + prodsum_self(x, self.K)       # &#34;convection&#34; of x
            + prodsum_K1(y, y) * self.b**2  # &#34;convection&#34; of y
            + prodsum_K1(y, x) * self.c     # coupling
            + -x - y*self.b                 # damping
            + self.Force
        )

    def step1(self, x0, t, dt):
        return rk4(lambda x, t: self.dxdt(x), x0, np.nan, dt)
    # Note: step1 is already ensemble compatible.
    # However, it is a bit slow, so we can gain in speed by using multiprocessing.

    # TODO 4: the same pattern is used for the QG model. Merge, and  it a decorator?
    def step(self, E, t, dt):
        if E.ndim == 1:
            return self.step1(E, t, dt)
        if E.ndim == 2:
            if self.mp and E.size &gt; 1e5:
                # TODO 4: using dapper.tools.multiproc.Pool yielded
                # &#34;Too many files open&#34; error. Fixed it as described here:
                # https://stackoverflow.com/q/45665991
                import multiprocessing_on_dill as mpd

                def f(E):
                    return self.step1(E, t=t, dt=dt)
                with mpd.Pool() as pool:
                    E = pool.map(f, E)
                E = np.array(E)
            else:
                for n, x in enumerate(E):
                    E[n] = self.step1(x, t, dt)
            return E


def summation_kernel(width):
    &#34;&#34;&#34;Prepare computation of the modified sum in `bib.lorenz2005designing`.

    Note: This gets repeatedly called, but actually the input is only ever
    `width = K` or `2*J`, so we should really cache or pre-compute.
    But with default system parameters and N=50, the savings are negligible.
    &#34;&#34;&#34;
    r = width // 2  # &#34;radius&#34;
    weights = np.ones(2*r + 1)
    if width != len(weights):
        weights[0] = weights[-1] = .5
    inds0 = np.arange(-r, r+1)
    return r, weights, inds0


def boxcar(x, n, method=&#34;direct&#34;):
    &#34;&#34;&#34;Moving average (boxcar filter) on `x` using `n` nearest (periodically) elements.

    For symmetry, if `n` is pair, the actual number of elements used is `n+1`,
    and the outer elements weighted by 0.5 to compensate for the `+1`.

    This is the modified sum of `bib.lorenz2005designing`, used e.g. in eqn. 9.
    For intuition: this type of summation (and the associated Sigma prime notation)
    may also be found for the &#34;Trapezoidal rule&#34; and in the inverse DFT used in
    spectral methods on a periodic domain.

    Apart from this weighting, this constitutes merely a boxcar filter.
    There are of course several well-known implementations.  The computational
    suggestion suggested by Lorenz below eqn 10 could maybe be implemented
    (with vectorisation) using `cumsum`, but this seems tricky due to weighting
    and periodicity.

    [1](https://stackoverflow.com/q/14313510)
    [2](https://stackoverflow.com/q/13728392)
    [3](https://stackoverflow.com/a/38034801)

    In testing with default system parameters, and ensemble size N=50, the
    &#34;direct&#34; method is generally 2x faster than the &#34;fft&#34; method, and the &#34;oa&#34;
    method is a little slower again. If `K` or `J` is increased, then the &#34;fft&#34;
    method becomes the fastest.

    Examples:
    &gt;&gt;&gt; x = np.array([0, 1, 2], dtype=float)
    &gt;&gt;&gt; np.allclose(boxcar(x, 1), x)
    True
    &gt;&gt;&gt; boxcar(x, 2)
    array([0.75, 1.  , 1.25])
    &gt;&gt;&gt; boxcar(x, 3)
    array([1., 1., 1.])
    &gt;&gt;&gt; x = np.arange(10, dtype=float)
    &gt;&gt;&gt; boxcar(x, 2)
    array([2.5, 1. , 2. , 3. , 4. , 5. , 6. , 7. , 8. , 6.5])
    &gt;&gt;&gt; boxcar(x, 5)
    array([4., 3., 2., 3., 4., 5., 6., 7., 6., 5.])
    &#34;&#34;&#34;
    r, weights, inds0 = summation_kernel(n)
    M = x.shape[-1]

    if method == &#34;manual&#34;:
        def mod(ind):
            return np.mod(ind, M)
        a = np.zeros_like(x)
        for m in range(M):
            a[..., m] = x[..., mod(m + inds0)] @ weights
            # for i, w in zip(inds0, weights):
            #     a[..., m] += x[..., mod(m + i)] * w

    elif method in [&#34;fft&#34;, &#34;oa&#34;]:
        # - Requires wrapping the state vector for periodicity.
        #   Maybe this could be avoided if we do the fft ourselves?
        # - `np.convolve` does not support multi-dim arrays (for ensembles).
        # - `ss.convolve` either does the computation &#34;directly&#34; itself,
        #   or delegates the job to ss.fftconvolve or ss.oaconvolve.
        #   Strangely, only the latter subroutines support the axis argument
        #   so we must call them ourselves.
        if method == &#34;fft&#34;:
            from scipy.signal import fftconvolve as convolver
        else:
            from scipy.signal import oaconvolve as convolver
        weights = weights[... if x.ndim == 1 else None]  # dim compatibility
        xxx = np.hstack([x[..., -r:], x, x[..., :r]])  # wrap
        a = convolver(xxx, weights, axes=-1)
        a = a[..., 2*r:-2*r]  # Trim (rm wrapped edges)

    else:  # method == &#34;direct&#34;:
        # AFAICT, this uses &#34;direct&#34; computations.
        a = convolve1d(x, weights, mode=&#34;wrap&#34;)

    a /= n
    return a


def shift(x, k):
    &#34;&#34;&#34;Rolls `x` leftwards. I.e. `output[i] = input[i+k]`.

    Notes about speed that usually hold when testing with ensemble DA:
    - This implementation is somewhat faster than `x[..., np.mod(ii + k, M)]`.
    - Computational savings of re-using already shifted vectors (or matrices)
      compared to just calling this function again are negligible.
    &#34;&#34;&#34;
    return np.roll(x, -k, axis=-1)


def prodsum_self(x, k):
    &#34;&#34;&#34;Compute `prodsum(x, x, k)` efficiently: eqn 10 of `bib.lorenz2005designing`.&#34;&#34;&#34;
    W = boxcar(x, k)
    WW = shift(W, -2*k) * shift(W, -k)
    WX = shift(W, -k) * shift(x, k)
    WX = boxcar(WX, k)
    return - WW + WX


def prodsum_K1(x, y):
    &#34;&#34;&#34;Compute `prodsum(x, y, 1)` efficiently.&#34;&#34;&#34;
    return -shift(x, -2) * shift(y, -1) + shift(x, -1) * shift(y, +1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dapper.mods.LorenzIII.summation_kernel"><code class="name flex">
<span>def <span class="ident">summation_kernel</span></span>(<span>width)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare computation of the modified sum in <code><a title="bib.lorenz2005designing" href="../../../bib.html#bib.lorenz2005designing">lorenz2005designing</a></code>.</p>
<p>Note: This gets repeatedly called, but actually the input is only ever
<code>width = K</code> or <code>2*J</code>, so we should really cache or pre-compute.
But with default system parameters and N=50, the savings are negligible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L114-L126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def summation_kernel(width):
    &#34;&#34;&#34;Prepare computation of the modified sum in `bib.lorenz2005designing`.

    Note: This gets repeatedly called, but actually the input is only ever
    `width = K` or `2*J`, so we should really cache or pre-compute.
    But with default system parameters and N=50, the savings are negligible.
    &#34;&#34;&#34;
    r = width // 2  # &#34;radius&#34;
    weights = np.ones(2*r + 1)
    if width != len(weights):
        weights[0] = weights[-1] = .5
    inds0 = np.arange(-r, r+1)
    return r, weights, inds0</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.boxcar"><code class="name flex">
<span>def <span class="ident">boxcar</span></span>(<span>x, n, method='direct')</span>
</code></dt>
<dd>
<div class="desc"><p>Moving average (boxcar filter) on <code>x</code> using <code>n</code> nearest (periodically) elements.</p>
<p>For symmetry, if <code>n</code> is pair, the actual number of elements used is <code>n+1</code>,
and the outer elements weighted by 0.5 to compensate for the <code>+1</code>.</p>
<p>This is the modified sum of <code><a title="bib.lorenz2005designing" href="../../../bib.html#bib.lorenz2005designing">lorenz2005designing</a></code>, used e.g. in eqn. 9.
For intuition: this type of summation (and the associated Sigma prime notation)
may also be found for the "Trapezoidal rule" and in the inverse DFT used in
spectral methods on a periodic domain.</p>
<p>Apart from this weighting, this constitutes merely a boxcar filter.
There are of course several well-known implementations.
The computational
suggestion suggested by Lorenz below eqn 10 could maybe be implemented
(with vectorisation) using <code>cumsum</code>, but this seems tricky due to weighting
and periodicity.</p>
<p><a href="https://stackoverflow.com/q/14313510">1</a>
<a href="https://stackoverflow.com/q/13728392">2</a>
<a href="https://stackoverflow.com/a/38034801">3</a></p>
<p>In testing with default system parameters, and ensemble size N=50, the
"direct" method is generally 2x faster than the "fft" method, and the "oa"
method is a little slower again. If <code>K</code> or <code>J</code> is increased, then the "fft"
method becomes the fastest.</p>
<p>Examples:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x = np.array([0, 1, 2], dtype=float)
&gt;&gt;&gt; np.allclose(boxcar(x, 1), x)
True
&gt;&gt;&gt; boxcar(x, 2)
array([0.75, 1.  , 1.25])
&gt;&gt;&gt; boxcar(x, 3)
array([1., 1., 1.])
&gt;&gt;&gt; x = np.arange(10, dtype=float)
&gt;&gt;&gt; boxcar(x, 2)
array([2.5, 1. , 2. , 3. , 4. , 5. , 6. , 7. , 8. , 6.5])
&gt;&gt;&gt; boxcar(x, 5)
array([4., 3., 2., 3., 4., 5., 6., 7., 6., 5.])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L129-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boxcar(x, n, method=&#34;direct&#34;):
    &#34;&#34;&#34;Moving average (boxcar filter) on `x` using `n` nearest (periodically) elements.

    For symmetry, if `n` is pair, the actual number of elements used is `n+1`,
    and the outer elements weighted by 0.5 to compensate for the `+1`.

    This is the modified sum of `bib.lorenz2005designing`, used e.g. in eqn. 9.
    For intuition: this type of summation (and the associated Sigma prime notation)
    may also be found for the &#34;Trapezoidal rule&#34; and in the inverse DFT used in
    spectral methods on a periodic domain.

    Apart from this weighting, this constitutes merely a boxcar filter.
    There are of course several well-known implementations.  The computational
    suggestion suggested by Lorenz below eqn 10 could maybe be implemented
    (with vectorisation) using `cumsum`, but this seems tricky due to weighting
    and periodicity.

    [1](https://stackoverflow.com/q/14313510)
    [2](https://stackoverflow.com/q/13728392)
    [3](https://stackoverflow.com/a/38034801)

    In testing with default system parameters, and ensemble size N=50, the
    &#34;direct&#34; method is generally 2x faster than the &#34;fft&#34; method, and the &#34;oa&#34;
    method is a little slower again. If `K` or `J` is increased, then the &#34;fft&#34;
    method becomes the fastest.

    Examples:
    &gt;&gt;&gt; x = np.array([0, 1, 2], dtype=float)
    &gt;&gt;&gt; np.allclose(boxcar(x, 1), x)
    True
    &gt;&gt;&gt; boxcar(x, 2)
    array([0.75, 1.  , 1.25])
    &gt;&gt;&gt; boxcar(x, 3)
    array([1., 1., 1.])
    &gt;&gt;&gt; x = np.arange(10, dtype=float)
    &gt;&gt;&gt; boxcar(x, 2)
    array([2.5, 1. , 2. , 3. , 4. , 5. , 6. , 7. , 8. , 6.5])
    &gt;&gt;&gt; boxcar(x, 5)
    array([4., 3., 2., 3., 4., 5., 6., 7., 6., 5.])
    &#34;&#34;&#34;
    r, weights, inds0 = summation_kernel(n)
    M = x.shape[-1]

    if method == &#34;manual&#34;:
        def mod(ind):
            return np.mod(ind, M)
        a = np.zeros_like(x)
        for m in range(M):
            a[..., m] = x[..., mod(m + inds0)] @ weights
            # for i, w in zip(inds0, weights):
            #     a[..., m] += x[..., mod(m + i)] * w

    elif method in [&#34;fft&#34;, &#34;oa&#34;]:
        # - Requires wrapping the state vector for periodicity.
        #   Maybe this could be avoided if we do the fft ourselves?
        # - `np.convolve` does not support multi-dim arrays (for ensembles).
        # - `ss.convolve` either does the computation &#34;directly&#34; itself,
        #   or delegates the job to ss.fftconvolve or ss.oaconvolve.
        #   Strangely, only the latter subroutines support the axis argument
        #   so we must call them ourselves.
        if method == &#34;fft&#34;:
            from scipy.signal import fftconvolve as convolver
        else:
            from scipy.signal import oaconvolve as convolver
        weights = weights[... if x.ndim == 1 else None]  # dim compatibility
        xxx = np.hstack([x[..., -r:], x, x[..., :r]])  # wrap
        a = convolver(xxx, weights, axes=-1)
        a = a[..., 2*r:-2*r]  # Trim (rm wrapped edges)

    else:  # method == &#34;direct&#34;:
        # AFAICT, this uses &#34;direct&#34; computations.
        a = convolve1d(x, weights, mode=&#34;wrap&#34;)

    a /= n
    return a</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>x, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Rolls <code>x</code> leftwards. I.e. <code>output[i] = input[i+k]</code>.</p>
<p>Notes about speed that usually hold when testing with ensemble DA:
- This implementation is somewhat faster than <code>x[..., np.mod(ii + k, M)]</code>.
- Computational savings of re-using already shifted vectors (or matrices)
compared to just calling this function again are negligible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L206-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shift(x, k):
    &#34;&#34;&#34;Rolls `x` leftwards. I.e. `output[i] = input[i+k]`.

    Notes about speed that usually hold when testing with ensemble DA:
    - This implementation is somewhat faster than `x[..., np.mod(ii + k, M)]`.
    - Computational savings of re-using already shifted vectors (or matrices)
      compared to just calling this function again are negligible.
    &#34;&#34;&#34;
    return np.roll(x, -k, axis=-1)</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.prodsum_self"><code class="name flex">
<span>def <span class="ident">prodsum_self</span></span>(<span>x, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute <code>prodsum(x, x, k)</code> efficiently: eqn 10 of <code><a title="bib.lorenz2005designing" href="../../../bib.html#bib.lorenz2005designing">lorenz2005designing</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L217-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prodsum_self(x, k):
    &#34;&#34;&#34;Compute `prodsum(x, x, k)` efficiently: eqn 10 of `bib.lorenz2005designing`.&#34;&#34;&#34;
    W = boxcar(x, k)
    WW = shift(W, -2*k) * shift(W, -k)
    WX = shift(W, -k) * shift(x, k)
    WX = boxcar(WX, k)
    return - WW + WX</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.prodsum_K1"><code class="name flex">
<span>def <span class="ident">prodsum_K1</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute <code>prodsum(x, y, 1)</code> efficiently.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L226-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prodsum_K1(x, y):
    &#34;&#34;&#34;Compute `prodsum(x, y, 1)` efficiently.&#34;&#34;&#34;
    return -shift(x, -2) * shift(y, -1) + shift(x, -1) * shift(y, +1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dapper.mods.LorenzIII.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>M:Â intÂ =Â 960, J:Â intÂ =Â 12, K:Â intÂ =Â 32, b:Â floatÂ =Â 10, c:Â floatÂ =Â 2.5, Force:Â floatÂ =Â 15, mp:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>The model configuration.</p>
<p>Functionality that does not directly depend on the model parameters
has been left outside of this class.</p>
<p>Using OOP (rather than module-level encapsulation) facilitates
working with multiple parameter settings simultaneously.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L35-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Model:
    &#34;&#34;&#34;The model configuration.

    Functionality that does not directly depend on the model parameters
    has been left outside of this class.

    Using OOP (rather than module-level encapsulation) facilitates
    working with multiple parameter settings simultaneously.
    &#34;&#34;&#34;
    M    : int   = 960  # state vector length
    J    : int   = 12   # decomposition kernel radius (width/2)
    K    : int   = 32   # smoothing kernel width (increase for +smooth and -waves)
    b    : float = 10   # scaling of small-scale variability
    c    : float = 2.5  # coupling strength
    Force: float = 15   # forcing

    mp   : bool  = False

    def __post_init__(self):
        J = self.J
        self.alpha = (3*J**2 + 3) / (2*J**3 + 4*J)
        self.beta  = (2*J**2 + 1) / (J**4 + 2*J**2)

        # Heuristic
        self.x0 = 2.8*np.ones(self.M)
        self.x0[0] += 0.1*self.Force

    def decompose(self, z):
        &#34;&#34;&#34;Split `z` into `x` and `y` fields, where `x` is the large-scale component.&#34;&#34;&#34;
        width = 2*self.J  # not +1 coz the sum in Lorenz eqn 13a is never ordinary
        _, weights, inds0 = summation_kernel(width)
        weights *= self.alpha - self.beta*abs(inds0)
        x = convolve1d(z, weights, mode=&#34;wrap&#34;)
        # Manual implementation:
        # x = np.zeros_like(z)
        # for m in range(M):
        #     for i, w in zip(inds0, weights):
        #         x[..., m] += w * z[..., mod(m + i)]
        y = z - x
        return x, y

    def dxdt(self, z):
        x, y = self.decompose(z)

        return (
            + prodsum_self(x, self.K)       # &#34;convection&#34; of x
            + prodsum_K1(y, y) * self.b**2  # &#34;convection&#34; of y
            + prodsum_K1(y, x) * self.c     # coupling
            + -x - y*self.b                 # damping
            + self.Force
        )

    def step1(self, x0, t, dt):
        return rk4(lambda x, t: self.dxdt(x), x0, np.nan, dt)
    # Note: step1 is already ensemble compatible.
    # However, it is a bit slow, so we can gain in speed by using multiprocessing.

    # TODO 4: the same pattern is used for the QG model. Merge, and  it a decorator?
    def step(self, E, t, dt):
        if E.ndim == 1:
            return self.step1(E, t, dt)
        if E.ndim == 2:
            if self.mp and E.size &gt; 1e5:
                # TODO 4: using dapper.tools.multiproc.Pool yielded
                # &#34;Too many files open&#34; error. Fixed it as described here:
                # https://stackoverflow.com/q/45665991
                import multiprocessing_on_dill as mpd

                def f(E):
                    return self.step1(E, t=t, dt=dt)
                with mpd.Pool() as pool:
                    E = pool.map(f, E)
                E = np.array(E)
            else:
                for n, x in enumerate(E):
                    E[n] = self.step1(x, t, dt)
            return E</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dapper.mods.LorenzIII.Model.M"><code class="name">var <span class="ident">M</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.mods.LorenzIII.Model.J"><code class="name">var <span class="ident">J</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.mods.LorenzIII.Model.K"><code class="name">var <span class="ident">K</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.mods.LorenzIII.Model.b"><code class="name">var <span class="ident">b</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.mods.LorenzIII.Model.c"><code class="name">var <span class="ident">c</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.mods.LorenzIII.Model.Force"><code class="name">var <span class="ident">Force</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.mods.LorenzIII.Model.mp"><code class="name">var <span class="ident">mp</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.mods.LorenzIII.Model.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>self, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Split <code>z</code> into <code>x</code> and <code>y</code> fields, where <code>x</code> is the large-scale component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L62-L74" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decompose(self, z):
    &#34;&#34;&#34;Split `z` into `x` and `y` fields, where `x` is the large-scale component.&#34;&#34;&#34;
    width = 2*self.J  # not +1 coz the sum in Lorenz eqn 13a is never ordinary
    _, weights, inds0 = summation_kernel(width)
    weights *= self.alpha - self.beta*abs(inds0)
    x = convolve1d(z, weights, mode=&#34;wrap&#34;)
    # Manual implementation:
    # x = np.zeros_like(z)
    # for m in range(M):
    #     for i, w in zip(inds0, weights):
    #         x[..., m] += w * z[..., mod(m + i)]
    y = z - x
    return x, y</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.Model.dxdt"><code class="name flex">
<span>def <span class="ident">dxdt</span></span>(<span>self, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L76-L85" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dxdt(self, z):
    x, y = self.decompose(z)

    return (
        + prodsum_self(x, self.K)       # &#34;convection&#34; of x
        + prodsum_K1(y, y) * self.b**2  # &#34;convection&#34; of y
        + prodsum_K1(y, x) * self.c     # coupling
        + -x - y*self.b                 # damping
        + self.Force
    )</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.Model.step1"><code class="name flex">
<span>def <span class="ident">step1</span></span>(<span>self, x0, t, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L87-L88" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def step1(self, x0, t, dt):
    return rk4(lambda x, t: self.dxdt(x), x0, np.nan, dt)</code></pre>
</details>
</dd>
<dt id="dapper.mods.LorenzIII.Model.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, E, t, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/mods/LorenzIII/__init__.py#L93-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def step(self, E, t, dt):
    if E.ndim == 1:
        return self.step1(E, t, dt)
    if E.ndim == 2:
        if self.mp and E.size &gt; 1e5:
            # TODO 4: using dapper.tools.multiproc.Pool yielded
            # &#34;Too many files open&#34; error. Fixed it as described here:
            # https://stackoverflow.com/q/45665991
            import multiprocessing_on_dill as mpd

            def f(E):
                return self.step1(E, t=t, dt=dt)
            with mpd.Pool() as pool:
                E = pool.map(f, E)
            E = np.array(E)
        else:
            for n, x in enumerate(E):
                E[n] = self.step1(x, t, dt)
        return E</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="DAPPER" href="https://nansencenter.github.io/DAPPER">
<img src="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo_wtxt.png" alt="">
<!-- can add style="width:200px;" to img -->
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/nansencenter/DAPPER site:nansencenter.github.io/DAPPER"
data-gaCategoryParameter="dapper.mods.LorenzIII">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dapper.mods" href="../index.html">dapper.mods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dapper.mods.LorenzIII.summation_kernel" href="#dapper.mods.LorenzIII.summation_kernel">summation_kernel</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.boxcar" href="#dapper.mods.LorenzIII.boxcar">boxcar</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.shift" href="#dapper.mods.LorenzIII.shift">shift</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.prodsum_self" href="#dapper.mods.LorenzIII.prodsum_self">prodsum_self</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.prodsum_K1" href="#dapper.mods.LorenzIII.prodsum_K1">prodsum_K1</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dapper.mods.LorenzIII.Model" href="#dapper.mods.LorenzIII.Model">Model</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.mods.LorenzIII.Model.decompose" href="#dapper.mods.LorenzIII.Model.decompose">decompose</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.dxdt" href="#dapper.mods.LorenzIII.Model.dxdt">dxdt</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.step1" href="#dapper.mods.LorenzIII.Model.step1">step1</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.step" href="#dapper.mods.LorenzIII.Model.step">step</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.M" href="#dapper.mods.LorenzIII.Model.M">M</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.J" href="#dapper.mods.LorenzIII.Model.J">J</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.K" href="#dapper.mods.LorenzIII.Model.K">K</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.b" href="#dapper.mods.LorenzIII.Model.b">b</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.c" href="#dapper.mods.LorenzIII.Model.c">c</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.Force" href="#dapper.mods.LorenzIII.Model.Force">Force</a></code></li>
<li><code><a title="dapper.mods.LorenzIII.Model.mp" href="#dapper.mods.LorenzIII.Model.mp">mp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>