<!-- Search file for "CHANGE" for my own changes -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dapper.xp_process API documentation</title>
<meta name="description" content="Tools (notably `xpSpace`) for processing and presenting experiment data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo.png">
<!-- Dont work coz pdoc already defines these:
<title>DAPPER doc</title>
<meta name="description" content="Data Assimilation with Python: a Package for Experimental Research" />
-->
<a href="https://github.com/nansencenter/DAPPER" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dapper.xp_process</code></h1>
</header>
<section id="section-intro">
<p>Tools (notably <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code>) for processing and presenting experiment data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L1-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Tools (notably `xpSpace`) for processing and presenting experiment data.&#34;&#34;&#34;

import collections
import copy
import warnings

import colorama
import numpy as np
from mpl_tools import place
from patlib.std import nonchalance
from struct_tools import AlignedDict, complement, intersect, transps
from tabulate import tabulate

from dapper.dpr_config import rc
from dapper.stats import align_col, unpack_uqs
from dapper.tools.colors import color_text, stripe
from dapper.tools.rounding import UncertainQtty
from dapper.tools.viz import NoneDict, default_styles
from dapper.xp_launch import xpList


class SparseSpace(dict):
    &#34;&#34;&#34;Subclass of `dict` that enforces key conformity to a given `namedtuple`.

    Like a normal `dict`, it can hold any type of objects.
    But, since the keys must conform, they effectively follow a coordinate system,
    so that the `dict` becomes a vector **space**.

    The coordinate system is specified by the `dims`:
    a list of keys defining the `namedtuple` of `self.Coord`.

    In intended usage, this space is highly sparse,
    meaning there are many coordinates with no entry.
    Indeed, as a data format for nd-arrays, it may be called
    &#34;coordinate list representation&#34;, used e.g. by `scipy.sparse.coo_matrix`.

    Thus, operations across (potentially multiple) `dims`,
    such as optimization or averaging, should be carried out by iterating
    -- not over the `dims` -- but over the the list of items.

    The most important method is `nest`,
    which is used (by `xpSpace.table_tree`) to print and plot results.

    In addition, `__getitem__` is quite flexible, allowing accessing by:

    - The actual key, a `self.Coord` object, or a standard tuple. Returns single item.
    - A `slice` or `list`. Returns list.
      Can be used to get single item with `dct[[idx]][0]`.

    Of course, indexing by slice or list assumes that the dict is ordered,
    which we inherit from the builtin `dict` since Python 3.7.
    Moreover, it is a reflection of the fact that the internals of this class
    work by looping over items.

    Other convenience functions: `.subspace` (alias `.__call__`) and `.coords_matching`.

    Inspired by

    - https://stackoverflow.com/a/7728830
    - https://stackoverflow.com/q/3387691

    Example:
    &gt;&gt;&gt; dct = xpSpace([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;])
    &gt;&gt;&gt; dct[(1, 2, 3)] = &#34;point 1&#34;
    &gt;&gt;&gt; dct[1, 2, 3] == dct[(1, 2, 3)] == dct[dct.Coord(1, 2, 3)] == &#34;point 1&#34;
    True

    This dict only has three `dims`, so this fails:
    &gt;&gt;&gt; dct[(1, 2, 3, 4)]
    Traceback (most recent call last):
    ...
    KeyError: (1, 2, 3, 4)

    Individual coordinates can be anything. For example `None`:
    &gt;&gt;&gt; dct[(1, 2, None)] = &#34;point 2&#34;
    &#34;&#34;&#34;

    @property
    def dims(self):
        return self.Coord._fields

    def __init__(self, dims):
        &#34;&#34;&#34;Usually initialized through `xpSpace.from_list`.

        Parameters
        ----------
        dims: list or tuple
            The attributes defining the coordinate system.
        &#34;&#34;&#34;
        # Define coordinate system
        self.Coord = collections.namedtuple(&#39;Coord&#39;, dims)

        def repr2(c, keys=False, str_or_repr=repr):
            if keys:
                lst = [f&#34;{k}={str_or_repr(v)}&#34; for k, v in c._asdict().items()]
            else:
                lst = [str_or_repr(v) for v in c]
            return &#34;(&#34; + &#34;, &#34;.join(lst) + &#34;)&#34;

        self.Coord.repr2 = repr2

    def update(self, items):
        &#34;&#34;&#34;Update dict, using the custom `__setitem__` to ensure key conformity.

        NB: the `kwargs` syntax is not supported because it only works for keys that
        consist of (a single) string, which is not very interesting for SparseSpace.
        &#34;&#34;&#34;
        # See https://stackoverflow.com/a/2588648
        # and https://stackoverflow.com/a/2390997
        try:
            items = items.items()
        except AttributeError:
            pass
        for k, v in items:
            self[k] = v

    def __setitem__(self, key, val):
        &#34;&#34;&#34;Setitem ensuring coordinate conforms.&#34;&#34;&#34;
        try:
            key = self.Coord(*key)
        except TypeError:
            raise TypeError(
                f&#34;The key {key!r} did not fit the coord. system &#34;
                f&#34;which has dims {self.dims}&#34;)
        super().__setitem__(key, val)

    def __getitem__(self, key):
        &#34;&#34;&#34;Also allows list-indexing by `list` and `slice`.&#34;&#34;&#34;
        # List of items (from list of indices)
        if isinstance(key, list):
            lst = list(self.values())
            return [lst[k] for k in key]

        # List of items (from slice)
        elif isinstance(key, slice):
            return [*self.values()][key]

        # Single item (by Coord object, or tuple)
        else:
            # NB: Dont&#39;t use isinstance(key, self.Coord)
            # coz it fails when the namedtuple (Coord) has been
            # instantiated in different places (but with equal params).
            # Also see bugs.python.org/issue7796
            return super().__getitem__(key)

    def __call__(self, **kwargs):
        &#34;&#34;&#34;Shortcut (syntactic sugar) for `SparseSpace.subspace`.&#34;&#34;&#34;
        return self.subspace(**kwargs)

    def subspace(self, **kwargs):
        &#34;&#34;&#34;Get an affine subspace.

        NB: If you&#39;re calling this repeatedly (for all values of the same `kwargs`)
        then you should consider using `SparseSpace.nest` instead.

        Example
        -------
            xp_dict.subspace(da_method=&#34;EnKF&#34;, infl=1, seed=3)
        &#34;&#34;&#34;
        # Slow version
        # outer = self.nest(outer_dims=list(kwargs))  # make subspaceS
        # inner = outer[outer.Coord(**kwargs)]        # discard all but 1

        coords = self.coords_matching(**kwargs)
        inner = self.__class__(complement(self.dims, kwargs))
        for coord in coords:
            inner[inner.coord_from_attrs(coord)] = self[coord]

        return inner

    def coords_matching(self, **kwargs):
        &#34;&#34;&#34;Get all `coord`s matching kwargs.

        Used by `SparseSpace.label_xSection` and `SparseSpace.subspace`. Unlike the
        latter, this function returns a *list* of *keys* of the *original subspace*.

        Note that the `missingval` shenanigans of `xpList.inds` are here unnecessary
        since each coordinate is complete.
        &#34;&#34;&#34;
        def match(coord):
            return all(getattr(coord, k) == kwargs[k] for k in kwargs)

        return [c for c in self if match(c)]

    def coord_from_attrs(self, obj):
        &#34;&#34;&#34;Form a `coord` for this `xpSpace` by extracting attrs. from `obj`.

        For instances of `self.Coord`, this is the identity opeartor.

        ```py
        self.coord_from_attrs(coord) == coord
        ```
        &#34;&#34;&#34;
        coord = (getattr(obj, a, None) for a in self.dims)
        return self.Coord(*coord)

    def __repr__(self):
        txt  = f&#34;&lt;{self.__class__.__name__}&gt;&#34;
        txt += &#34; with Coord/dims: &#34;
        try:
            txt += &#34;(and ticks): &#34; + str(AlignedDict(self.ticks))
        except AttributeError:
            txt += str(self.dims) + &#34;\n&#34;

        # Note: print(xpList(self)) produces a more human-readable table,
        # but requires prep_table(), which we don&#39;t really want to call again
        # (it&#39;s only called in from_list, not (necessarily) in any nested spaces)
        L = 2
        keys = [k.repr2() for k in self]
        if 2*L &lt; len(keys):
            keys = keys[:L] + [&#34;...&#34;] + keys[-L:]
        keys = &#34;[\n  &#34; + &#34;,\n  &#34;.join(keys) + &#34;\n]&#34;
        return txt + f&#34;populated by {len(self)} items with keys: {keys}&#34;

    def nest(self, inner_dims=None, outer_dims=None):
        &#34;&#34;&#34;Project along `inner_acces` to yield a new `xpSpace` with dims `outer_dims`

        The entries of this `xpSpace` are themselves `xpSpace`s, with dims `inner_dims`,
        each one regrouping the entries with the same (projected) coordinate.

        Note: is also called by `__getitem__(key)` if `key` is dict.
        &#34;&#34;&#34;
        # Default: a singleton outer space,
        # with everything contained in the inner (projection) space.
        if inner_dims is None and outer_dims is None:
            outer_dims = ()

        # Validate dims
        if inner_dims is None:
            assert outer_dims is not None
            inner_dims = complement(self.dims, outer_dims)
        else:
            assert outer_dims is None
            outer_dims = complement(self.dims, inner_dims)

        # Fill spaces
        outer_space = self.__class__(outer_dims)
        for coord, entry in self.items():
            # Lookup subspace coord
            outer_coord = outer_space.coord_from_attrs(coord)
            try:
                # Get subspace
                inner_space = outer_space[outer_coord]
            except KeyError:
                # Create subspace, embed
                inner_space = self.__class__(inner_dims)
                outer_space[outer_coord] = inner_space
            # Add entry to subspace, similar to .fill()
            inner_space[inner_space.coord_from_attrs(coord)] = entry

        return outer_space

    def intersect_dims(self, attrs):
        &#34;&#34;&#34;Rm those `a` in `attrs` that are not in `self.dims`.

        This enables sloppy `dims` allotment, for ease-of-use.
        &#34;&#34;&#34;
        absent = complement(attrs, self.dims)
        if absent:
            print(color_text(&#34;Warning:&#34;, colorama.Fore.RED),
                  &#34;The requested attributes&#34;,
                  color_text(str(absent), colorama.Fore.RED),
                  (&#34;were not found among the&#34;
                   &#34; xpSpace dims (attrs. used as coordinates&#34;
                   &#34; for the set of experiments).&#34;
                   &#34; This may be no problem if the attr. is redundant&#34;
                   &#34; for the coord-sys.&#34;
                   &#34; However, if it is caused by confusion or mis-spelling,&#34;
                   &#34; then it is likely to cause mis-interpretation&#34;
                   &#34; of the shown results.&#34;))
            attrs = complement(attrs, absent)
        return attrs

    def append_dim(self, dim):
        &#34;&#34;&#34;Expand `self.Coord` by `dim`. For each item, insert `None` in new dim.&#34;&#34;&#34;
        self.__init__(self.dims+(dim,))
        for coord in list(self):
            entry = self.pop(coord)
            self[coord + (None,)] = entry

    def label_xSection(self, label, *NoneAttrs, **sub_coord):
        &#34;&#34;&#34;Insert duplicate entries for the given cross-section.

        Works by adding the attr. `xSection` to the dims of `SparseSpace`,
        and setting it to `label` for entries matching `sub_coord`,
        reflecting the &#34;constance/constraint/fixation&#34; this represents.
        This distinguishes the entries in this fixed-affine subspace,
        preventing them from being gobbled up by the operations of `nest`.

        If you wish, you can specify the `NoneAttrs`,
        which are consequently set to None for the duplicated entries,
        preventing them from being shown in plot labels and tuning panels.
        &#34;&#34;&#34;
        if &#34;xSect&#34; not in self.dims:
            self.append_dim(&#39;xSect&#39;)

        for coord in self.coords_matching(**self.intersect_dims(sub_coord)):
            entry = copy.deepcopy(self[coord])
            coord = coord._replace(xSect=label)
            coord = coord._replace(**{a: None for a in NoneAttrs})
            self[coord] = entry


DIM_ROLES = dict(outer=None, inner=None, mean=None, optim=None)


class xpSpace(SparseSpace):
    &#34;&#34;&#34;Functionality to facilitate working with `xps` and their results.&#34;&#34;&#34;

    @classmethod
    def from_list(cls, xps, tick_ordering=None):
        &#34;&#34;&#34;Init. from a list of objects, typically experiments referred to as `xp`s.

        - Computes the relevant `dims` from the attributes, and
        - Fills the dict by `xp`s.
        - Computes and writes the attribute `ticks`.

        This creates a `SparseSpace` of `xp`s. However, the nested subspaces generated
        by `xpSpace.table_tree` (for printing and plotting) will hold objects of type
        `UncertainQtty`, because it calls `mean` which calls `get_stat(statkey)`.
        &#34;&#34;&#34;
        # Define and fill SparseSpace
        dct = xpList(xps).prep_table(nomerge=[&#39;xSect&#39;])[0]
        self = cls(dct.keys())
        self.fill(xps)
        self.make_ticks(dct, tick_ordering)
        return self

    def make_ticks(self, dct, ordering=None):
        &#34;&#34;&#34;Unique &amp; sort, for each individual &#34;dim&#34; in `dct`. Assign to `self.ticks`.

        NB: `self.ticks` will not &#34;propagate&#34; through `SparseSpace.nest` or the like.
        &#34;&#34;&#34;
        self.ticks = dct
        ordering = ordering or {}
        for name, values in dct.items():
            ticks = set(values)  # unique (jumbles order)
            order = ordering.get(name, &#39;as-found&#39;)

            # Sort key
            if callable(order):
                key = order
            elif &#39;as-found&#39; in order:
                key = values.index
            else:  # &#34;natural&#34;
                def key(x):
                    return x

            # Place None&#39;s at the end
            def key_safe(x):
                return (x is None), key(x)

            # Sort
            ticks = sorted(ticks, key=key_safe)
            # Reverse
            if isinstance(order, str) and &#34;rev&#34; in order:
                ticks = ticks[::-1]
            # Assign
            dct[name] = ticks

    def fill(self, xps):
        &#34;&#34;&#34;Mass insertion.&#34;&#34;&#34;
        self.update([(self.coord_from_attrs(xp), xp) for xp in xps])

    def squeeze(self):
        &#34;&#34;&#34;Eliminate unnecessary dimensions.&#34;&#34;&#34;
        squeezed = xpSpace(xpList(self).prep_table()[0])
        squeezed.fill(self)
        return squeezed

    def get_stat(self, statkey=&#34;rmse.a&#34;):
        &#34;&#34;&#34;Make `xpSpace` with same `Coord` as `self`, but values `xp.avrgs.statkey`.&#34;&#34;&#34;
        # Init a new xpDict to hold stat
        avrgs = self.__class__(self.dims)

        found_anything = False
        for coord, xp in self.items():
            val = getattr(xp.avrgs, statkey, None)
            avrgs[coord] = val
            found_anything = found_anything or (val is not None)

        if not found_anything:
            raise AttributeError(
                f&#34;The stat.&#39;{statkey}&#39; was not found among any of the xp&#39;s.&#34;)

        return avrgs

    def mean(self, dims=None):
        &#34;&#34;&#34;Compute mean over `dims` (a list). Returns `xpSpace` without those `dims`.&#34;&#34;&#34;
        # Note: The case `dims=()` should work w/o special treatment.
        if dims is None:
            return self

        nested = self.nest(dims)
        for coord, space in nested.items():

            def getval(uq):
                return uq.val if isinstance(uq, UncertainQtty) else uq
            vals = [getval(uq) for uq in space.values()]

            # Don&#39;t use nanmean! It would give false impressions.
            mu = np.mean(vals)

            with warnings.catch_warnings():
                warnings.simplefilter(&#34;ignore&#34;, category=RuntimeWarning)
                # Don&#39;t print warnings caused by N=1.
                # It already correctly yield nan&#39;s.
                var = np.var(vals, ddof=1)

            N = len(vals)
            uq = UncertainQtty(mu, np.sqrt(var/N))
            uq.nTotal   = N
            uq.nFail    = N - np.isfinite(vals).sum()
            uq.nSuccess = N - uq.nFail

            nested[coord] = uq
        return nested

    def tune(self, dims=None, costfun=None):
        &#34;&#34;&#34;Get (compile/tabulate) a stat. optimised wrt. tuning params (`dims`).&#34;&#34;&#34;
        # Define cost-function
        costfun = (costfun or &#39;increasing&#39;).lower()
        if &#39;increas&#39; in costfun:
            costfun = (lambda x: +x)
        elif &#39;decreas&#39; in costfun:
            costfun = (lambda x: -x)
        else:
            assert callable(costfun)  # custom

        # Note: The case `dims=()` should work w/o special treatment.
        if dims is None:
            return self

        nested = self.nest(dims)
        for coord, space in nested.items():
            # Find optimal value (and coord) within space
            MIN = np.inf
            found_any = False
            for inner_coord, uq in space.items():
                cost = costfun(uq.val)
                if cost &lt;= MIN:
                    found_any          = True
                    MIN                = cost
                    uq_opt             = uq
                    uq_opt.tuned_coord = inner_coord

            if not found_any:
                uq_opt = uq  # one is as good as another
                nDim = range(len(space.Coord._fields))
                uq_opt.tuned_coord = space.Coord(*(None for _ in nDim))

            nested[coord] = uq_opt

        return nested

    def validate_dims(self, dims):
        &#34;&#34;&#34;Validate dims.

        Note: This does not convert None to (), allowing None to remain special.
              Use `()` if tuples are required.
        &#34;&#34;&#34;
        roles = {}  # &#34;inv&#34;
        for role in set(dims) | set(DIM_ROLES):
            assert role in DIM_ROLES, f&#34;Invalid role {role!r}&#34;
            dd = dims.get(role, DIM_ROLES[role])

            if dd is None:
                pass  # Purposely special
            else:
                # Ensure iterable
                if isinstance(dd, str) or not hasattr(dd, &#34;__iter__&#34;):
                    dd = (dd,)

                dd = self.intersect_dims(dd)

                for dim in dd:

                    # Ensure unique
                    if dim in roles:
                        raise TypeError(
                            f&#34;A dim (here {dim!r}) cannot be assigned to 2&#34;
                            f&#34; roles (here {role!r} and {roles[dim]!r}).&#34;)
                    else:
                        roles[dim] = role
            dims[role] = dd
        return dims

    def table_tree(self, statkey, dims, *, costfun=None):
        &#34;&#34;&#34;Make hierarchy `outer &gt; inner &gt; mean &gt; optim` using `SparseSpace.nest`.

        The dimension passed to `nest` (at each level) is specified by `dims`.
        The dimensions of `dims[&#39;mean&#39;]` and `dims[&#39;optim&#39;]` get eliminated
        by the mean/tune operations. The `dims[&#39;outer&#39;]` and `dims[&#39;inner&#39;]
        become the keys for the output hierarchy.

        .. note::
            cannot support multiple `statkey`s because it&#39;s not (obviously) meaningful
            when optimizing over `dims[&#39;optim&#39;]`.
        &#34;&#34;&#34;
        dims = self.validate_dims(dims)

        def mean_tune(xp_dict):
            &#34;&#34;&#34;Take mean, then tune.

            Note: the `SparseSpace` implementation should be sufficiently
            &#34;uncluttered&#34; that `mean_tune` (or a few of its code lines)
            could be called anywhere above/between/below
            the `nest`ing of `outer` or `inner`.
            These possibile call locations are commented in the code.
            &#34;&#34;&#34;
            uq_dict = xp_dict.get_stat(statkey)
            uq_dict = uq_dict.mean(dims[&#39;mean&#39;])
            uq_dict = uq_dict.tune(dims[&#39;optim&#39;], costfun)
            return uq_dict

        self2 = mean_tune(self)
        # Prefer calling mean_tune() [also see its docstring]
        # before doing outer/inner nesting. This is because then the dims of
        # a row (xpSpace) should not include mean&amp;optim, and thus:
        #  - Column header/coords may be had directly as row.keys(),
        #    without extraction by coord_from_attrs() from (e.g.) row[0].
        #  - Don&#39;t need to propagate mean&amp;optim dims down to the row level.
        #    which would require defining rows by the nesting:
        #    rows = table.nest(outer_dims=complement(table.dims,
        #        *(dims[&#39;inner&#39;] or ()),
        #        *(dims[&#39;mean&#39;]  or ()),
        #        *(dims[&#39;optim&#39;] or ()) ))
        #  - Each level of the output from table_tree
        #    is a smaller (and more manageable) dict.

        tables = self2.nest(outer_dims=dims[&#39;outer&#39;])
        for table_coord, table in tables.items():
            # table = mean_tune(table)

            # Should not be used (nesting as rows is more natural,
            # and is required for getting distinct/row_keys).
            # cols = table.nest(outer_dims=dims[&#39;inner&#39;])

            rows = table.nest(inner_dims=dims[&#39;inner&#39;] or ())

            # Overwrite table by its nesting as rows
            tables[table_coord] = rows

            # for row_coord, row in rows.items():
            # rows[row_coord] = mean_tune(row)

        args = dict(statkey=statkey, xp_dict=self, dims=dims)
        tables.created_with = args
        return dims, tables

    def tickz(self, dim_name):
        &#34;&#34;&#34;Dimension (axis) ticks without None&#34;&#34;&#34;
        return [x for x in self.ticks[dim_name] if x is not None]

    def print(self, statkey, dims,  # noqa (shadowing builtin)
              subcols=True, decimals=None, costfun=None,
              squeeze_labels=True, colorize=True):
        &#34;&#34;&#34;Print tables of results.

        Parameters
        ----------
        statkey: str
            The statistic to extract from the `xp.avrgs` for each `xp`.
        dims: dict
            Allots (maps) the dims of `xpSpace` to different roles in the tables.

            - The &#34;role&#34; `outer` should list the dims/attributes
              used to define the splitting of the results into *separate tables*:
              one table for each distinct combination of attributes.
            - Similarly , the role `inner` determines which attributes
              split a table into its columns.
            - `mean` lists the attributes over which the mean is taken
              (for that row &amp; column)
            - `optim` lists the attributes used over which the optimum
               is searched for (after taking the mean).

            Example:

                dict(outer=&#39;da_method&#39;, inner=&#39;N&#39;, mean=&#39;seed&#39;,
                     optim=(&#39;infl&#39;,&#39;loc_rad&#39;))

            Equivalently, use `mean=(&#34;seed&#34;,)`.
            It is acceptible to leave this empty: `mean=()` or `mean=None`.
        subcols: bool
            If `True`, then subcolumns are added to indicate

            - `1σ`: the confidence interval. If `mean=None` is used, this simply reports
              the value `.prec` of the `statkey`, providing this is an `UncertainQtty`.
              Otherwise, it is computed as `sqrt(var(xps)/N)`,
              where `xps` is the set of statistic gathered over the `mean` dimensions.
            - `*(optim)`: the optimal point (among all `optim` attributes),
              as defined by `costfun`.
            - `☠`: the number of failures (non-finite values) at that point.
            - `✓`: the number of successes that go into the value
        decimals: int
            Number of decimals to print.
            If `None`, this is determined for each statistic by its uncertainty.
        costfun: str or function
            Use `&#39;increasing&#39;` (default) or `&#39;decreasing&#39;` to indicate that the optimum
            is defined as the lowest or highest value of the `statkey` found.
        squeeze_labels: bool
            Don&#39;t include redundant attributes in the line labels.
            Caution: `get_style` will not be able to access the eliminated attrs.
        colorize: bool
            Add color to tables for readability.
        &#34;&#34;&#34;
        # Inform dims[&#34;mean&#34;]
        if dims.get(&#39;mean&#39;, None):
            print(f&#34;Averages (in time and) over {dims[&#39;mean&#39;]}.&#34;)
        else:
            print(&#34;Averages in time only&#34;
                  &#34; (=&gt; the 1σ estimates may be unreliable).&#34;)

        def make_cols(rows, cc, subcols, h2):
            &#34;&#34;&#34;Subcolumns: align, justify, join.&#34;&#34;&#34;
            # Define subcol formats
            if subcols:
                templ = &#34;{val} ±{prec}&#34;
                templ += &#34;&#34; if dims[&#39;optim&#39;] is None else &#34; *{tuned_coord}&#34;
                templ += &#34;&#34; if  dims[&#39;mean&#39;] is None else &#34; {nFail} {nSuccess}&#34;  # noqa
                aligns = dict(prec=&#34;&lt;&#34;, tuned_coord=&#34;&lt;&#34;)
                labels = dict(val=statkey, prec=&#34;1σ&#34;,
                              tuned_coord=dims[&#34;optim&#34;],
                              nFail=&#34;☠&#34;, nSuccess=&#34;✓&#34;)

            def align(column):
                col = unpack_uqs(column, decimals)
                if subcols:
                    for key in list(col):
                        if key in templ:
                            subcolmn = [labels.get(key, key)] + col[key]
                            col[key] = align_col(subcolmn, just=aligns.get(key, &#34;&gt;&#34;))
                        else:
                            del col[key]
                    col = [templ.format(**row) for row in transps(col)]
                else:
                    col = align_col([statkey] + col[&#34;val&#34;])
                return col

            def super_header(col_coord, idx, col):
                header, matter = col[0], col[1:]
                cc = col_coord.repr2(not idx, str).strip(&#34;()&#34;).replace(&#34;, &#34;, &#34;,&#34;)
                cc = cc.center(len(header), &#34;_&#34;)  # +1 width for wide chars like ✔️
                return [cc + &#34;\n&#34; + header] + matter

            # Transpose
            columns = [list(x) for x in zip(*rows)]

            # Format column
            for j, (col_coord, column) in enumerate(zip(cc, columns)):
                col = align(column)
                if h2:
                    col = super_header(col_coord, j, col)
                columns[j] = col

            # Un-transpose
            rows = [list(x) for x in zip(*columns)]

            return rows

        dims, tables = self.table_tree(statkey, dims, costfun=costfun)

        for table_coord, table in tables.items():

            # Get table&#39;s column coords/ticks (cc).
            # cc is really a set, but we use dict for ordering.
            # cc = self.ticks[dims[&#34;inner&#34;]]  # may be &gt; needed
            # cc = table[0].keys()            # may be &lt; needed
            cc = {c: None for row in table.values() for c in row}
            # Could additionally do cc = table.squeeze() but is it worth it?

            # Convert table (rows) into rows (lists) of equal length
            rows = [[row.get(c, None) for c in cc] for row in table.values()]

            # Align cols
            h2 = &#34;\n&#34; if len(cc) &gt; 1 else &#34;&#34;  # super-header?
            headers, *rows = make_cols(rows, cc, subcols, h2)

            # Prepend left-side (attr) table
            if squeeze_labels:
                table = table.squeeze()
            headers = [h2+k for k in table.dims] + [h2+&#39;⑊&#39;] + headers
            for i, (key, row) in enumerate(zip(table, rows)):
                rows[i] = [*key] + [&#39;|&#39;] + row

            print()
            if dims[&#39;outer&#39;]:
                # Title
                table_title = &#34;Table for &#34; + table_coord.repr2(True).strip(&#34;()&#34;)
                if colorize:
                    clrs = colorama.Back.YELLOW, colorama.Fore.BLACK
                    table_title = color_text(table_title, *clrs)
                print(table_title)
            table = tabulate(rows, headers).replace(&#39;␣&#39;, &#39; &#39;)
            if colorize:
                table = stripe(table, slice(2, None))
            print(table)

        return tables

    def plot(self, statkey, dims, get_style=default_styles,
             fignum=None, figsize=None, panels=None, costfun=None,
             title1=None, title2=None, unique_labels=True, squeeze_labels=True):
        &#34;&#34;&#34;Plot (tables of) results.

        Analagously to `xpSpace.print`,
        the averages are grouped by `dims[&#34;inner&#34;]`,
        which here plays the role of the x-axis.

        The averages can also be grouped by `dims[&#34;outer&#34;]`,
        producing a figure with multiple (columns of) panels.

        The optimal points/parameters/attributes are plotted in smaller panels
        below the main plot. This can be turned off by providing the figure
        dims through the `panels` argument.

        The parameters `statkey`, `dims`, `costfun`, `sqeeze_labels`
        are documented in `xpSpace.print`.

        Parameters
        ----------
        get_style: function
            A function that takes an object, and returns a dict of line styles,
            usually as a function of the object&#39;s attributes.
        title1: anything
            Figure title (in addition to the the defaults).
        title2: anything
            Figure title (in addition to the defaults). Goes on a new line.
        unique_labels: bool
            Only show a given line label once, even if it appears in several panels.
        squeeze_labels:
            Don&#39;t include redundant attributes in the labels.
        &#34;&#34;&#34;
        def plot1(panelcol, row, style):
            &#34;&#34;&#34;Plot a given line (row) in the main panel and the optim panels.

            Involves: Sort, insert None&#39;s, handle constant lines.
            &#34;&#34;&#34;
            # Make a full row (yy) of vals, whether is_constant or not.
            # is_constant = (len(row)==1 and next(iter(row))==row.Coord(None))
            is_constant = all(x == row.Coord(None) for x in row)
            if is_constant:
                yy = [row[None, ] for _ in xticks]
                style.marker = None
            else:
                yy = [row.get(row.Coord(x), None) for x in xticks]

            # Plot main
            row.vals = [getattr(y, &#39;val&#39;, None) for y in yy]
            row.handles = {}
            row.handles[&#34;main_panel&#34;] = panelcol[0].plot(xticks, row.vals, **style)[0]

            # Plot tuning params
            row.tuned_coords = {}  # Store ordered, &#34;transposed&#34; argmins
            argmins = [getattr(y, &#39;tuned_coord&#39;, None) for y in yy]
            for a, panel in zip(dims[&#34;optim&#34;], panelcol[1:]):
                yy = [getattr(coord, a, None) for coord in argmins]
                row.tuned_coords[a] = yy

                # Plotting all None&#39;s sets axes units (like any plotting call)
                # which can cause trouble if the axes units were actually supposed
                # to be categorical (eg upd_a), but this is only revealed later.
                if not all(y == None for y in yy):
                    row.handles[a] = panel.plot(xticks, yy, **style)

        def label_management(table):
            def pruner(style):
                label = style.get(&#34;label&#34;, None)
                if unique_labels:
                    if label in register:
                        del style[&#34;label&#34;]
                    elif label:
                        register.add(style[&#34;label&#34;])
                        pruner.has_labels = True
                elif label:
                    pruner.has_labels = True
            pruner.has_labels = False

            def squeezer(coord):
                return intersect(coord._asdict(), label_attrs)
            if squeeze_labels:
                label_attrs = xpList(table.keys()).prep_table()[0]
            else:
                label_attrs = table.dims

            return pruner, squeezer
        register = set()

        def beautify(panels, title, has_labels):
            panel0 = panels[0]
            # panel0.set_title(title)
            panel0.text(.5, 1, title, fontsize=12, ha=&#34;center&#34;, va=&#34;bottom&#34;,
                        transform=panel0.transAxes, bbox=dict(
                            facecolor=&#39;lightyellow&#39;, edgecolor=&#39;k&#39;,
                            alpha=0.99, boxstyle=&#34;round,pad=0.25&#34;,
                            # NB: padding makes label spill into axes
                        ))
            if has_labels:
                panel0.legend()
            if panel0.is_first_col():
                panel0.set_ylabel(statkey)
            panels[-1].set_xlabel(dims[&#34;inner&#34;][0])
            # Tuning panels:
            for a, panel in zip(dims[&#34;optim&#34;] or (), panels[1:]):
                if panel.is_first_col():
                    panel.set_ylabel(f&#34;Optim.\n{a}&#34;)

        # Nest dims through table_tree()
        assert len(dims[&#34;inner&#34;]) == 1, &#34;You must chose the abscissa.&#34;
        dims, tables = self.table_tree(statkey, dims, costfun=costfun)

        if not hasattr(self, &#34;ticks&#34;):
            # TODO 6: this is probationary.
            # In case self is actually a subspace, it may be that it does not contain
            # all of the ticks of the original xpSpace. This may be fine,
            # and we generate the ticks here again. However, this is costly-ish, so you
            # should maybe simply (manually) assign them from the original xpSpace.
            # And maybe you actually want the plotted lines to have holes where self
            # has no values. Changes in the ticks are not obvious to the naked eye,
            # unlike the case for printed tables (where column changes are quite clear).
            print(color_text(&#34;Warning:&#34;, colorama.Fore.RED), &#34;Making new x-ticks.&#34;
                  &#34;\nConsider assigning them yourself from the original&#34;
                  &#34; xpSpace to this subspace.&#34;)
            self.make_ticks(xpList(self).prep_table()[0])
        xticks = self.tickz(dims[&#34;inner&#34;][0])

        # Create figure axes
        if panels is None:
            nrows   = len(dims[&#39;optim&#39;] or ()) + 1
            ncols   = len(tables)
            maxW    = 12.7  # my mac screen
            figsize = figsize or (min(5*ncols, maxW), 7)
            gs      = dict(
                height_ratios=[6]+[1]*(nrows-1),
                hspace=0.05, wspace=0.05,
                # eyeballed:
                left=0.15/(1+np.log(ncols)),
                right=0.97, bottom=0.06, top=0.9)
            # Create
            _, panels = place.freshfig(num=fignum, figsize=figsize,
                                       nrows=nrows, sharex=True,
                                       ncols=ncols, sharey=&#39;row&#39;,
                                       gridspec_kw=gs, squeeze=False)
        else:
            panels = np.atleast_2d(panels)

        # Fig. Title
        fig = panels[0, 0].figure
        fig_title = &#34;Averages wrt. time&#34;
        if dims[&#34;mean&#34;] is not None:
            fig_title += &#34; and &#34; + &#34;, &#34;.join([repr(c) for c in dims[&#39;mean&#39;]])
        if title1 is not None:
            fig_title += &#34;. &#34; + title1
        if title2 is not None:
            with nonchalance():
                title2 = title2.relative_to(rc.dirs[&#34;data&#34;])
            fig_title += &#34;\n&#34; + str(title2)
        fig.suptitle(fig_title)

        # Loop outer
        for ax_column, (table_coord, table) in zip(panels.T, tables.items()):
            table.panels = ax_column
            label_prune, label_squeeze = label_management(table)
            for coord, row in table.items():
                style = get_style(NoneDict(label_squeeze(coord)))
                label_prune(style)
                plot1(table.panels, row, style)

            beautify(table.panels,
                     title=(&#34;&#34; if dims[&#34;outer&#34;] is None else
                            table_coord.repr2(True).strip(&#34;()&#34;)),
                     has_labels=label_prune.has_labels)

        tables.fig = fig  # add reference to fig
        return tables</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dapper.xp_process.SparseSpace"><code class="flex name class">
<span>class <span class="ident">SparseSpace</span></span>
<span>(</span><span>dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Subclass of <code>dict</code> that enforces key conformity to a given <code>namedtuple</code>.</p>
<p>Like a normal <code>dict</code>, it can hold any type of objects.
But, since the keys must conform, they effectively follow a coordinate system,
so that the <code>dict</code> becomes a vector <strong>space</strong>.</p>
<p>The coordinate system is specified by the <code>dims</code>:
a list of keys defining the <code>namedtuple</code> of <code>self.Coord</code>.</p>
<p>In intended usage, this space is highly sparse,
meaning there are many coordinates with no entry.
Indeed, as a data format for nd-arrays, it may be called
"coordinate list representation", used e.g. by <code>scipy.sparse.coo_matrix</code>.</p>
<p>Thus, operations across (potentially multiple) <code>dims</code>,
such as optimization or averaging, should be carried out by iterating
&ndash; not over the <code>dims</code> &ndash; but over the the list of items.</p>
<p>The most important method is <code>nest</code>,
which is used (by <code><a title="dapper.xp_process.xpSpace.table_tree" href="#dapper.xp_process.xpSpace.table_tree">xpSpace.table_tree()</a></code>) to print and plot results.</p>
<p>In addition, <code>__getitem__</code> is quite flexible, allowing accessing by:</p>
<ul>
<li>The actual key, a <code>self.Coord</code> object, or a standard tuple. Returns single item.</li>
<li>A <code>slice</code> or <code>list</code>. Returns list.
Can be used to get single item with <code>dct[[idx]][0]</code>.</li>
</ul>
<p>Of course, indexing by slice or list assumes that the dict is ordered,
which we inherit from the builtin <code>dict</code> since Python 3.7.
Moreover, it is a reflection of the fact that the internals of this class
work by looping over items.</p>
<p>Other convenience functions: <code>.subspace</code> (alias <code>.__call__</code>) and <code>.coords_matching</code>.</p>
<p>Inspired by</p>
<ul>
<li><a href="https://stackoverflow.com/a/7728830">https://stackoverflow.com/a/7728830</a></li>
<li><a href="https://stackoverflow.com/q/3387691">https://stackoverflow.com/q/3387691</a></li>
</ul>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dct = xpSpace([&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
&gt;&gt;&gt; dct[(1, 2, 3)] = &quot;point 1&quot;
&gt;&gt;&gt; dct[1, 2, 3] == dct[(1, 2, 3)] == dct[dct.Coord(1, 2, 3)] == &quot;point 1&quot;
True
</code></pre>
<p>This dict only has three <code>dims</code>, so this fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dct[(1, 2, 3, 4)]
Traceback (most recent call last):
...
KeyError: (1, 2, 3, 4)
</code></pre>
<p>Individual coordinates can be anything. For example <code>None</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dct[(1, 2, None)] = &quot;point 2&quot;
</code></pre>
<p>Usually initialized through <code><a title="dapper.xp_process.xpSpace.from_list" href="#dapper.xp_process.xpSpace.from_list">xpSpace.from_list()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>The attributes defining the coordinate system.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L22-L301" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SparseSpace(dict):
    &#34;&#34;&#34;Subclass of `dict` that enforces key conformity to a given `namedtuple`.

    Like a normal `dict`, it can hold any type of objects.
    But, since the keys must conform, they effectively follow a coordinate system,
    so that the `dict` becomes a vector **space**.

    The coordinate system is specified by the `dims`:
    a list of keys defining the `namedtuple` of `self.Coord`.

    In intended usage, this space is highly sparse,
    meaning there are many coordinates with no entry.
    Indeed, as a data format for nd-arrays, it may be called
    &#34;coordinate list representation&#34;, used e.g. by `scipy.sparse.coo_matrix`.

    Thus, operations across (potentially multiple) `dims`,
    such as optimization or averaging, should be carried out by iterating
    -- not over the `dims` -- but over the the list of items.

    The most important method is `nest`,
    which is used (by `xpSpace.table_tree`) to print and plot results.

    In addition, `__getitem__` is quite flexible, allowing accessing by:

    - The actual key, a `self.Coord` object, or a standard tuple. Returns single item.
    - A `slice` or `list`. Returns list.
      Can be used to get single item with `dct[[idx]][0]`.

    Of course, indexing by slice or list assumes that the dict is ordered,
    which we inherit from the builtin `dict` since Python 3.7.
    Moreover, it is a reflection of the fact that the internals of this class
    work by looping over items.

    Other convenience functions: `.subspace` (alias `.__call__`) and `.coords_matching`.

    Inspired by

    - https://stackoverflow.com/a/7728830
    - https://stackoverflow.com/q/3387691

    Example:
    &gt;&gt;&gt; dct = xpSpace([&#34;x&#34;, &#34;y&#34;, &#34;z&#34;])
    &gt;&gt;&gt; dct[(1, 2, 3)] = &#34;point 1&#34;
    &gt;&gt;&gt; dct[1, 2, 3] == dct[(1, 2, 3)] == dct[dct.Coord(1, 2, 3)] == &#34;point 1&#34;
    True

    This dict only has three `dims`, so this fails:
    &gt;&gt;&gt; dct[(1, 2, 3, 4)]
    Traceback (most recent call last):
    ...
    KeyError: (1, 2, 3, 4)

    Individual coordinates can be anything. For example `None`:
    &gt;&gt;&gt; dct[(1, 2, None)] = &#34;point 2&#34;
    &#34;&#34;&#34;

    @property
    def dims(self):
        return self.Coord._fields

    def __init__(self, dims):
        &#34;&#34;&#34;Usually initialized through `xpSpace.from_list`.

        Parameters
        ----------
        dims: list or tuple
            The attributes defining the coordinate system.
        &#34;&#34;&#34;
        # Define coordinate system
        self.Coord = collections.namedtuple(&#39;Coord&#39;, dims)

        def repr2(c, keys=False, str_or_repr=repr):
            if keys:
                lst = [f&#34;{k}={str_or_repr(v)}&#34; for k, v in c._asdict().items()]
            else:
                lst = [str_or_repr(v) for v in c]
            return &#34;(&#34; + &#34;, &#34;.join(lst) + &#34;)&#34;

        self.Coord.repr2 = repr2

    def update(self, items):
        &#34;&#34;&#34;Update dict, using the custom `__setitem__` to ensure key conformity.

        NB: the `kwargs` syntax is not supported because it only works for keys that
        consist of (a single) string, which is not very interesting for SparseSpace.
        &#34;&#34;&#34;
        # See https://stackoverflow.com/a/2588648
        # and https://stackoverflow.com/a/2390997
        try:
            items = items.items()
        except AttributeError:
            pass
        for k, v in items:
            self[k] = v

    def __setitem__(self, key, val):
        &#34;&#34;&#34;Setitem ensuring coordinate conforms.&#34;&#34;&#34;
        try:
            key = self.Coord(*key)
        except TypeError:
            raise TypeError(
                f&#34;The key {key!r} did not fit the coord. system &#34;
                f&#34;which has dims {self.dims}&#34;)
        super().__setitem__(key, val)

    def __getitem__(self, key):
        &#34;&#34;&#34;Also allows list-indexing by `list` and `slice`.&#34;&#34;&#34;
        # List of items (from list of indices)
        if isinstance(key, list):
            lst = list(self.values())
            return [lst[k] for k in key]

        # List of items (from slice)
        elif isinstance(key, slice):
            return [*self.values()][key]

        # Single item (by Coord object, or tuple)
        else:
            # NB: Dont&#39;t use isinstance(key, self.Coord)
            # coz it fails when the namedtuple (Coord) has been
            # instantiated in different places (but with equal params).
            # Also see bugs.python.org/issue7796
            return super().__getitem__(key)

    def __call__(self, **kwargs):
        &#34;&#34;&#34;Shortcut (syntactic sugar) for `SparseSpace.subspace`.&#34;&#34;&#34;
        return self.subspace(**kwargs)

    def subspace(self, **kwargs):
        &#34;&#34;&#34;Get an affine subspace.

        NB: If you&#39;re calling this repeatedly (for all values of the same `kwargs`)
        then you should consider using `SparseSpace.nest` instead.

        Example
        -------
            xp_dict.subspace(da_method=&#34;EnKF&#34;, infl=1, seed=3)
        &#34;&#34;&#34;
        # Slow version
        # outer = self.nest(outer_dims=list(kwargs))  # make subspaceS
        # inner = outer[outer.Coord(**kwargs)]        # discard all but 1

        coords = self.coords_matching(**kwargs)
        inner = self.__class__(complement(self.dims, kwargs))
        for coord in coords:
            inner[inner.coord_from_attrs(coord)] = self[coord]

        return inner

    def coords_matching(self, **kwargs):
        &#34;&#34;&#34;Get all `coord`s matching kwargs.

        Used by `SparseSpace.label_xSection` and `SparseSpace.subspace`. Unlike the
        latter, this function returns a *list* of *keys* of the *original subspace*.

        Note that the `missingval` shenanigans of `xpList.inds` are here unnecessary
        since each coordinate is complete.
        &#34;&#34;&#34;
        def match(coord):
            return all(getattr(coord, k) == kwargs[k] for k in kwargs)

        return [c for c in self if match(c)]

    def coord_from_attrs(self, obj):
        &#34;&#34;&#34;Form a `coord` for this `xpSpace` by extracting attrs. from `obj`.

        For instances of `self.Coord`, this is the identity opeartor.

        ```py
        self.coord_from_attrs(coord) == coord
        ```
        &#34;&#34;&#34;
        coord = (getattr(obj, a, None) for a in self.dims)
        return self.Coord(*coord)

    def __repr__(self):
        txt  = f&#34;&lt;{self.__class__.__name__}&gt;&#34;
        txt += &#34; with Coord/dims: &#34;
        try:
            txt += &#34;(and ticks): &#34; + str(AlignedDict(self.ticks))
        except AttributeError:
            txt += str(self.dims) + &#34;\n&#34;

        # Note: print(xpList(self)) produces a more human-readable table,
        # but requires prep_table(), which we don&#39;t really want to call again
        # (it&#39;s only called in from_list, not (necessarily) in any nested spaces)
        L = 2
        keys = [k.repr2() for k in self]
        if 2*L &lt; len(keys):
            keys = keys[:L] + [&#34;...&#34;] + keys[-L:]
        keys = &#34;[\n  &#34; + &#34;,\n  &#34;.join(keys) + &#34;\n]&#34;
        return txt + f&#34;populated by {len(self)} items with keys: {keys}&#34;

    def nest(self, inner_dims=None, outer_dims=None):
        &#34;&#34;&#34;Project along `inner_acces` to yield a new `xpSpace` with dims `outer_dims`

        The entries of this `xpSpace` are themselves `xpSpace`s, with dims `inner_dims`,
        each one regrouping the entries with the same (projected) coordinate.

        Note: is also called by `__getitem__(key)` if `key` is dict.
        &#34;&#34;&#34;
        # Default: a singleton outer space,
        # with everything contained in the inner (projection) space.
        if inner_dims is None and outer_dims is None:
            outer_dims = ()

        # Validate dims
        if inner_dims is None:
            assert outer_dims is not None
            inner_dims = complement(self.dims, outer_dims)
        else:
            assert outer_dims is None
            outer_dims = complement(self.dims, inner_dims)

        # Fill spaces
        outer_space = self.__class__(outer_dims)
        for coord, entry in self.items():
            # Lookup subspace coord
            outer_coord = outer_space.coord_from_attrs(coord)
            try:
                # Get subspace
                inner_space = outer_space[outer_coord]
            except KeyError:
                # Create subspace, embed
                inner_space = self.__class__(inner_dims)
                outer_space[outer_coord] = inner_space
            # Add entry to subspace, similar to .fill()
            inner_space[inner_space.coord_from_attrs(coord)] = entry

        return outer_space

    def intersect_dims(self, attrs):
        &#34;&#34;&#34;Rm those `a` in `attrs` that are not in `self.dims`.

        This enables sloppy `dims` allotment, for ease-of-use.
        &#34;&#34;&#34;
        absent = complement(attrs, self.dims)
        if absent:
            print(color_text(&#34;Warning:&#34;, colorama.Fore.RED),
                  &#34;The requested attributes&#34;,
                  color_text(str(absent), colorama.Fore.RED),
                  (&#34;were not found among the&#34;
                   &#34; xpSpace dims (attrs. used as coordinates&#34;
                   &#34; for the set of experiments).&#34;
                   &#34; This may be no problem if the attr. is redundant&#34;
                   &#34; for the coord-sys.&#34;
                   &#34; However, if it is caused by confusion or mis-spelling,&#34;
                   &#34; then it is likely to cause mis-interpretation&#34;
                   &#34; of the shown results.&#34;))
            attrs = complement(attrs, absent)
        return attrs

    def append_dim(self, dim):
        &#34;&#34;&#34;Expand `self.Coord` by `dim`. For each item, insert `None` in new dim.&#34;&#34;&#34;
        self.__init__(self.dims+(dim,))
        for coord in list(self):
            entry = self.pop(coord)
            self[coord + (None,)] = entry

    def label_xSection(self, label, *NoneAttrs, **sub_coord):
        &#34;&#34;&#34;Insert duplicate entries for the given cross-section.

        Works by adding the attr. `xSection` to the dims of `SparseSpace`,
        and setting it to `label` for entries matching `sub_coord`,
        reflecting the &#34;constance/constraint/fixation&#34; this represents.
        This distinguishes the entries in this fixed-affine subspace,
        preventing them from being gobbled up by the operations of `nest`.

        If you wish, you can specify the `NoneAttrs`,
        which are consequently set to None for the duplicated entries,
        preventing them from being shown in plot labels and tuning panels.
        &#34;&#34;&#34;
        if &#34;xSect&#34; not in self.dims:
            self.append_dim(&#39;xSect&#39;)

        for coord in self.coords_matching(**self.intersect_dims(sub_coord)):
            entry = copy.deepcopy(self[coord])
            coord = coord._replace(xSect=label)
            coord = coord._replace(**{a: None for a in NoneAttrs})
            self[coord] = entry</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dapper.xp_process.SparseSpace.dims"><code class="name">var <span class="ident">dims</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L78-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def dims(self):
    return self.Coord._fields</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.xp_process.SparseSpace.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"><p>Update dict, using the custom <code>__setitem__</code> to ensure key conformity.</p>
<p>NB: the <code>kwargs</code> syntax is not supported because it only works for keys that
consist of (a single) string, which is not very interesting for SparseSpace.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L102-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, items):
    &#34;&#34;&#34;Update dict, using the custom `__setitem__` to ensure key conformity.

    NB: the `kwargs` syntax is not supported because it only works for keys that
    consist of (a single) string, which is not very interesting for SparseSpace.
    &#34;&#34;&#34;
    # See https://stackoverflow.com/a/2588648
    # and https://stackoverflow.com/a/2390997
    try:
        items = items.items()
    except AttributeError:
        pass
    for k, v in items:
        self[k] = v</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.subspace"><code class="name flex">
<span>def <span class="ident">subspace</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an affine subspace.</p>
<p>NB: If you're calling this repeatedly (for all values of the same <code>kwargs</code>)
then you should consider using <code><a title="dapper.xp_process.SparseSpace.nest" href="#dapper.xp_process.SparseSpace.nest">SparseSpace.nest()</a></code> instead.</p>
<h2 id="example">Example</h2>
<pre><code>xp_dict.subspace(da_method="EnKF", infl=1, seed=3)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L150-L169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def subspace(self, **kwargs):
    &#34;&#34;&#34;Get an affine subspace.

    NB: If you&#39;re calling this repeatedly (for all values of the same `kwargs`)
    then you should consider using `SparseSpace.nest` instead.

    Example
    -------
        xp_dict.subspace(da_method=&#34;EnKF&#34;, infl=1, seed=3)
    &#34;&#34;&#34;
    # Slow version
    # outer = self.nest(outer_dims=list(kwargs))  # make subspaceS
    # inner = outer[outer.Coord(**kwargs)]        # discard all but 1

    coords = self.coords_matching(**kwargs)
    inner = self.__class__(complement(self.dims, kwargs))
    for coord in coords:
        inner[inner.coord_from_attrs(coord)] = self[coord]

    return inner</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.coords_matching"><code class="name flex">
<span>def <span class="ident">coords_matching</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all <code>coord</code>s matching kwargs.</p>
<p>Used by <code><a title="dapper.xp_process.SparseSpace.label_xSection" href="#dapper.xp_process.SparseSpace.label_xSection">SparseSpace.label_xSection()</a></code> and <code><a title="dapper.xp_process.SparseSpace.subspace" href="#dapper.xp_process.SparseSpace.subspace">SparseSpace.subspace()</a></code>. Unlike the
latter, this function returns a <em>list</em> of <em>keys</em> of the <em>original subspace</em>.</p>
<p>Note that the <code>missingval</code> shenanigans of <code>xpList.inds</code> are here unnecessary
since each coordinate is complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L171-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def coords_matching(self, **kwargs):
    &#34;&#34;&#34;Get all `coord`s matching kwargs.

    Used by `SparseSpace.label_xSection` and `SparseSpace.subspace`. Unlike the
    latter, this function returns a *list* of *keys* of the *original subspace*.

    Note that the `missingval` shenanigans of `xpList.inds` are here unnecessary
    since each coordinate is complete.
    &#34;&#34;&#34;
    def match(coord):
        return all(getattr(coord, k) == kwargs[k] for k in kwargs)

    return [c for c in self if match(c)]</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.coord_from_attrs"><code class="name flex">
<span>def <span class="ident">coord_from_attrs</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Form a <code>coord</code> for this <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code> by extracting attrs. from <code>obj</code>.</p>
<p>For instances of <code>self.Coord</code>, this is the identity opeartor.</p>
<pre><code class="language-py">self.coord_from_attrs(coord) == coord
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L185-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def coord_from_attrs(self, obj):
    &#34;&#34;&#34;Form a `coord` for this `xpSpace` by extracting attrs. from `obj`.

    For instances of `self.Coord`, this is the identity opeartor.

    ```py
    self.coord_from_attrs(coord) == coord
    ```
    &#34;&#34;&#34;
    coord = (getattr(obj, a, None) for a in self.dims)
    return self.Coord(*coord)</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.nest"><code class="name flex">
<span>def <span class="ident">nest</span></span>(<span>self, inner_dims=None, outer_dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Project along <code>inner_acces</code> to yield a new <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code> with dims <code>outer_dims</code></p>
<p>The entries of this <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code> are themselves <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code>s, with dims <code>inner_dims</code>,
each one regrouping the entries with the same (projected) coordinate.</p>
<p>Note: is also called by <code>__getitem__(key)</code> if <code>key</code> is dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L215-L251" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nest(self, inner_dims=None, outer_dims=None):
    &#34;&#34;&#34;Project along `inner_acces` to yield a new `xpSpace` with dims `outer_dims`

    The entries of this `xpSpace` are themselves `xpSpace`s, with dims `inner_dims`,
    each one regrouping the entries with the same (projected) coordinate.

    Note: is also called by `__getitem__(key)` if `key` is dict.
    &#34;&#34;&#34;
    # Default: a singleton outer space,
    # with everything contained in the inner (projection) space.
    if inner_dims is None and outer_dims is None:
        outer_dims = ()

    # Validate dims
    if inner_dims is None:
        assert outer_dims is not None
        inner_dims = complement(self.dims, outer_dims)
    else:
        assert outer_dims is None
        outer_dims = complement(self.dims, inner_dims)

    # Fill spaces
    outer_space = self.__class__(outer_dims)
    for coord, entry in self.items():
        # Lookup subspace coord
        outer_coord = outer_space.coord_from_attrs(coord)
        try:
            # Get subspace
            inner_space = outer_space[outer_coord]
        except KeyError:
            # Create subspace, embed
            inner_space = self.__class__(inner_dims)
            outer_space[outer_coord] = inner_space
        # Add entry to subspace, similar to .fill()
        inner_space[inner_space.coord_from_attrs(coord)] = entry

    return outer_space</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.intersect_dims"><code class="name flex">
<span>def <span class="ident">intersect_dims</span></span>(<span>self, attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Rm those <code>a</code> in <code>attrs</code> that are not in <code>self.dims</code>.</p>
<p>This enables sloppy <code>dims</code> allotment, for ease-of-use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L253-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersect_dims(self, attrs):
    &#34;&#34;&#34;Rm those `a` in `attrs` that are not in `self.dims`.

    This enables sloppy `dims` allotment, for ease-of-use.
    &#34;&#34;&#34;
    absent = complement(attrs, self.dims)
    if absent:
        print(color_text(&#34;Warning:&#34;, colorama.Fore.RED),
              &#34;The requested attributes&#34;,
              color_text(str(absent), colorama.Fore.RED),
              (&#34;were not found among the&#34;
               &#34; xpSpace dims (attrs. used as coordinates&#34;
               &#34; for the set of experiments).&#34;
               &#34; This may be no problem if the attr. is redundant&#34;
               &#34; for the coord-sys.&#34;
               &#34; However, if it is caused by confusion or mis-spelling,&#34;
               &#34; then it is likely to cause mis-interpretation&#34;
               &#34; of the shown results.&#34;))
        attrs = complement(attrs, absent)
    return attrs</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.append_dim"><code class="name flex">
<span>def <span class="ident">append_dim</span></span>(<span>self, dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Expand <code>self.Coord</code> by <code>dim</code>. For each item, insert <code>None</code> in new dim.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L274-L279" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def append_dim(self, dim):
    &#34;&#34;&#34;Expand `self.Coord` by `dim`. For each item, insert `None` in new dim.&#34;&#34;&#34;
    self.__init__(self.dims+(dim,))
    for coord in list(self):
        entry = self.pop(coord)
        self[coord + (None,)] = entry</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.SparseSpace.label_xSection"><code class="name flex">
<span>def <span class="ident">label_xSection</span></span>(<span>self, label, *NoneAttrs, **sub_coord)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert duplicate entries for the given cross-section.</p>
<p>Works by adding the attr. <code>xSection</code> to the dims of <code><a title="dapper.xp_process.SparseSpace" href="#dapper.xp_process.SparseSpace">SparseSpace</a></code>,
and setting it to <code>label</code> for entries matching <code>sub_coord</code>,
reflecting the "constance/constraint/fixation" this represents.
This distinguishes the entries in this fixed-affine subspace,
preventing them from being gobbled up by the operations of <code>nest</code>.</p>
<p>If you wish, you can specify the <code>NoneAttrs</code>,
which are consequently set to None for the duplicated entries,
preventing them from being shown in plot labels and tuning panels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L281-L301" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def label_xSection(self, label, *NoneAttrs, **sub_coord):
    &#34;&#34;&#34;Insert duplicate entries for the given cross-section.

    Works by adding the attr. `xSection` to the dims of `SparseSpace`,
    and setting it to `label` for entries matching `sub_coord`,
    reflecting the &#34;constance/constraint/fixation&#34; this represents.
    This distinguishes the entries in this fixed-affine subspace,
    preventing them from being gobbled up by the operations of `nest`.

    If you wish, you can specify the `NoneAttrs`,
    which are consequently set to None for the duplicated entries,
    preventing them from being shown in plot labels and tuning panels.
    &#34;&#34;&#34;
    if &#34;xSect&#34; not in self.dims:
        self.append_dim(&#39;xSect&#39;)

    for coord in self.coords_matching(**self.intersect_dims(sub_coord)):
        entry = copy.deepcopy(self[coord])
        coord = coord._replace(xSect=label)
        coord = coord._replace(**{a: None for a in NoneAttrs})
        self[coord] = entry</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dapper.xp_process.xpSpace"><code class="flex name class">
<span>class <span class="ident">xpSpace</span></span>
<span>(</span><span>dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Functionality to facilitate working with <code>xps</code> and their results.</p>
<p>Usually initialized through <code><a title="dapper.xp_process.xpSpace.from_list" href="#dapper.xp_process.xpSpace.from_list">xpSpace.from_list()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dims</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>The attributes defining the coordinate system.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L307-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xpSpace(SparseSpace):
    &#34;&#34;&#34;Functionality to facilitate working with `xps` and their results.&#34;&#34;&#34;

    @classmethod
    def from_list(cls, xps, tick_ordering=None):
        &#34;&#34;&#34;Init. from a list of objects, typically experiments referred to as `xp`s.

        - Computes the relevant `dims` from the attributes, and
        - Fills the dict by `xp`s.
        - Computes and writes the attribute `ticks`.

        This creates a `SparseSpace` of `xp`s. However, the nested subspaces generated
        by `xpSpace.table_tree` (for printing and plotting) will hold objects of type
        `UncertainQtty`, because it calls `mean` which calls `get_stat(statkey)`.
        &#34;&#34;&#34;
        # Define and fill SparseSpace
        dct = xpList(xps).prep_table(nomerge=[&#39;xSect&#39;])[0]
        self = cls(dct.keys())
        self.fill(xps)
        self.make_ticks(dct, tick_ordering)
        return self

    def make_ticks(self, dct, ordering=None):
        &#34;&#34;&#34;Unique &amp; sort, for each individual &#34;dim&#34; in `dct`. Assign to `self.ticks`.

        NB: `self.ticks` will not &#34;propagate&#34; through `SparseSpace.nest` or the like.
        &#34;&#34;&#34;
        self.ticks = dct
        ordering = ordering or {}
        for name, values in dct.items():
            ticks = set(values)  # unique (jumbles order)
            order = ordering.get(name, &#39;as-found&#39;)

            # Sort key
            if callable(order):
                key = order
            elif &#39;as-found&#39; in order:
                key = values.index
            else:  # &#34;natural&#34;
                def key(x):
                    return x

            # Place None&#39;s at the end
            def key_safe(x):
                return (x is None), key(x)

            # Sort
            ticks = sorted(ticks, key=key_safe)
            # Reverse
            if isinstance(order, str) and &#34;rev&#34; in order:
                ticks = ticks[::-1]
            # Assign
            dct[name] = ticks

    def fill(self, xps):
        &#34;&#34;&#34;Mass insertion.&#34;&#34;&#34;
        self.update([(self.coord_from_attrs(xp), xp) for xp in xps])

    def squeeze(self):
        &#34;&#34;&#34;Eliminate unnecessary dimensions.&#34;&#34;&#34;
        squeezed = xpSpace(xpList(self).prep_table()[0])
        squeezed.fill(self)
        return squeezed

    def get_stat(self, statkey=&#34;rmse.a&#34;):
        &#34;&#34;&#34;Make `xpSpace` with same `Coord` as `self`, but values `xp.avrgs.statkey`.&#34;&#34;&#34;
        # Init a new xpDict to hold stat
        avrgs = self.__class__(self.dims)

        found_anything = False
        for coord, xp in self.items():
            val = getattr(xp.avrgs, statkey, None)
            avrgs[coord] = val
            found_anything = found_anything or (val is not None)

        if not found_anything:
            raise AttributeError(
                f&#34;The stat.&#39;{statkey}&#39; was not found among any of the xp&#39;s.&#34;)

        return avrgs

    def mean(self, dims=None):
        &#34;&#34;&#34;Compute mean over `dims` (a list). Returns `xpSpace` without those `dims`.&#34;&#34;&#34;
        # Note: The case `dims=()` should work w/o special treatment.
        if dims is None:
            return self

        nested = self.nest(dims)
        for coord, space in nested.items():

            def getval(uq):
                return uq.val if isinstance(uq, UncertainQtty) else uq
            vals = [getval(uq) for uq in space.values()]

            # Don&#39;t use nanmean! It would give false impressions.
            mu = np.mean(vals)

            with warnings.catch_warnings():
                warnings.simplefilter(&#34;ignore&#34;, category=RuntimeWarning)
                # Don&#39;t print warnings caused by N=1.
                # It already correctly yield nan&#39;s.
                var = np.var(vals, ddof=1)

            N = len(vals)
            uq = UncertainQtty(mu, np.sqrt(var/N))
            uq.nTotal   = N
            uq.nFail    = N - np.isfinite(vals).sum()
            uq.nSuccess = N - uq.nFail

            nested[coord] = uq
        return nested

    def tune(self, dims=None, costfun=None):
        &#34;&#34;&#34;Get (compile/tabulate) a stat. optimised wrt. tuning params (`dims`).&#34;&#34;&#34;
        # Define cost-function
        costfun = (costfun or &#39;increasing&#39;).lower()
        if &#39;increas&#39; in costfun:
            costfun = (lambda x: +x)
        elif &#39;decreas&#39; in costfun:
            costfun = (lambda x: -x)
        else:
            assert callable(costfun)  # custom

        # Note: The case `dims=()` should work w/o special treatment.
        if dims is None:
            return self

        nested = self.nest(dims)
        for coord, space in nested.items():
            # Find optimal value (and coord) within space
            MIN = np.inf
            found_any = False
            for inner_coord, uq in space.items():
                cost = costfun(uq.val)
                if cost &lt;= MIN:
                    found_any          = True
                    MIN                = cost
                    uq_opt             = uq
                    uq_opt.tuned_coord = inner_coord

            if not found_any:
                uq_opt = uq  # one is as good as another
                nDim = range(len(space.Coord._fields))
                uq_opt.tuned_coord = space.Coord(*(None for _ in nDim))

            nested[coord] = uq_opt

        return nested

    def validate_dims(self, dims):
        &#34;&#34;&#34;Validate dims.

        Note: This does not convert None to (), allowing None to remain special.
              Use `()` if tuples are required.
        &#34;&#34;&#34;
        roles = {}  # &#34;inv&#34;
        for role in set(dims) | set(DIM_ROLES):
            assert role in DIM_ROLES, f&#34;Invalid role {role!r}&#34;
            dd = dims.get(role, DIM_ROLES[role])

            if dd is None:
                pass  # Purposely special
            else:
                # Ensure iterable
                if isinstance(dd, str) or not hasattr(dd, &#34;__iter__&#34;):
                    dd = (dd,)

                dd = self.intersect_dims(dd)

                for dim in dd:

                    # Ensure unique
                    if dim in roles:
                        raise TypeError(
                            f&#34;A dim (here {dim!r}) cannot be assigned to 2&#34;
                            f&#34; roles (here {role!r} and {roles[dim]!r}).&#34;)
                    else:
                        roles[dim] = role
            dims[role] = dd
        return dims

    def table_tree(self, statkey, dims, *, costfun=None):
        &#34;&#34;&#34;Make hierarchy `outer &gt; inner &gt; mean &gt; optim` using `SparseSpace.nest`.

        The dimension passed to `nest` (at each level) is specified by `dims`.
        The dimensions of `dims[&#39;mean&#39;]` and `dims[&#39;optim&#39;]` get eliminated
        by the mean/tune operations. The `dims[&#39;outer&#39;]` and `dims[&#39;inner&#39;]
        become the keys for the output hierarchy.

        .. note::
            cannot support multiple `statkey`s because it&#39;s not (obviously) meaningful
            when optimizing over `dims[&#39;optim&#39;]`.
        &#34;&#34;&#34;
        dims = self.validate_dims(dims)

        def mean_tune(xp_dict):
            &#34;&#34;&#34;Take mean, then tune.

            Note: the `SparseSpace` implementation should be sufficiently
            &#34;uncluttered&#34; that `mean_tune` (or a few of its code lines)
            could be called anywhere above/between/below
            the `nest`ing of `outer` or `inner`.
            These possibile call locations are commented in the code.
            &#34;&#34;&#34;
            uq_dict = xp_dict.get_stat(statkey)
            uq_dict = uq_dict.mean(dims[&#39;mean&#39;])
            uq_dict = uq_dict.tune(dims[&#39;optim&#39;], costfun)
            return uq_dict

        self2 = mean_tune(self)
        # Prefer calling mean_tune() [also see its docstring]
        # before doing outer/inner nesting. This is because then the dims of
        # a row (xpSpace) should not include mean&amp;optim, and thus:
        #  - Column header/coords may be had directly as row.keys(),
        #    without extraction by coord_from_attrs() from (e.g.) row[0].
        #  - Don&#39;t need to propagate mean&amp;optim dims down to the row level.
        #    which would require defining rows by the nesting:
        #    rows = table.nest(outer_dims=complement(table.dims,
        #        *(dims[&#39;inner&#39;] or ()),
        #        *(dims[&#39;mean&#39;]  or ()),
        #        *(dims[&#39;optim&#39;] or ()) ))
        #  - Each level of the output from table_tree
        #    is a smaller (and more manageable) dict.

        tables = self2.nest(outer_dims=dims[&#39;outer&#39;])
        for table_coord, table in tables.items():
            # table = mean_tune(table)

            # Should not be used (nesting as rows is more natural,
            # and is required for getting distinct/row_keys).
            # cols = table.nest(outer_dims=dims[&#39;inner&#39;])

            rows = table.nest(inner_dims=dims[&#39;inner&#39;] or ())

            # Overwrite table by its nesting as rows
            tables[table_coord] = rows

            # for row_coord, row in rows.items():
            # rows[row_coord] = mean_tune(row)

        args = dict(statkey=statkey, xp_dict=self, dims=dims)
        tables.created_with = args
        return dims, tables

    def tickz(self, dim_name):
        &#34;&#34;&#34;Dimension (axis) ticks without None&#34;&#34;&#34;
        return [x for x in self.ticks[dim_name] if x is not None]

    def print(self, statkey, dims,  # noqa (shadowing builtin)
              subcols=True, decimals=None, costfun=None,
              squeeze_labels=True, colorize=True):
        &#34;&#34;&#34;Print tables of results.

        Parameters
        ----------
        statkey: str
            The statistic to extract from the `xp.avrgs` for each `xp`.
        dims: dict
            Allots (maps) the dims of `xpSpace` to different roles in the tables.

            - The &#34;role&#34; `outer` should list the dims/attributes
              used to define the splitting of the results into *separate tables*:
              one table for each distinct combination of attributes.
            - Similarly , the role `inner` determines which attributes
              split a table into its columns.
            - `mean` lists the attributes over which the mean is taken
              (for that row &amp; column)
            - `optim` lists the attributes used over which the optimum
               is searched for (after taking the mean).

            Example:

                dict(outer=&#39;da_method&#39;, inner=&#39;N&#39;, mean=&#39;seed&#39;,
                     optim=(&#39;infl&#39;,&#39;loc_rad&#39;))

            Equivalently, use `mean=(&#34;seed&#34;,)`.
            It is acceptible to leave this empty: `mean=()` or `mean=None`.
        subcols: bool
            If `True`, then subcolumns are added to indicate

            - `1σ`: the confidence interval. If `mean=None` is used, this simply reports
              the value `.prec` of the `statkey`, providing this is an `UncertainQtty`.
              Otherwise, it is computed as `sqrt(var(xps)/N)`,
              where `xps` is the set of statistic gathered over the `mean` dimensions.
            - `*(optim)`: the optimal point (among all `optim` attributes),
              as defined by `costfun`.
            - `☠`: the number of failures (non-finite values) at that point.
            - `✓`: the number of successes that go into the value
        decimals: int
            Number of decimals to print.
            If `None`, this is determined for each statistic by its uncertainty.
        costfun: str or function
            Use `&#39;increasing&#39;` (default) or `&#39;decreasing&#39;` to indicate that the optimum
            is defined as the lowest or highest value of the `statkey` found.
        squeeze_labels: bool
            Don&#39;t include redundant attributes in the line labels.
            Caution: `get_style` will not be able to access the eliminated attrs.
        colorize: bool
            Add color to tables for readability.
        &#34;&#34;&#34;
        # Inform dims[&#34;mean&#34;]
        if dims.get(&#39;mean&#39;, None):
            print(f&#34;Averages (in time and) over {dims[&#39;mean&#39;]}.&#34;)
        else:
            print(&#34;Averages in time only&#34;
                  &#34; (=&gt; the 1σ estimates may be unreliable).&#34;)

        def make_cols(rows, cc, subcols, h2):
            &#34;&#34;&#34;Subcolumns: align, justify, join.&#34;&#34;&#34;
            # Define subcol formats
            if subcols:
                templ = &#34;{val} ±{prec}&#34;
                templ += &#34;&#34; if dims[&#39;optim&#39;] is None else &#34; *{tuned_coord}&#34;
                templ += &#34;&#34; if  dims[&#39;mean&#39;] is None else &#34; {nFail} {nSuccess}&#34;  # noqa
                aligns = dict(prec=&#34;&lt;&#34;, tuned_coord=&#34;&lt;&#34;)
                labels = dict(val=statkey, prec=&#34;1σ&#34;,
                              tuned_coord=dims[&#34;optim&#34;],
                              nFail=&#34;☠&#34;, nSuccess=&#34;✓&#34;)

            def align(column):
                col = unpack_uqs(column, decimals)
                if subcols:
                    for key in list(col):
                        if key in templ:
                            subcolmn = [labels.get(key, key)] + col[key]
                            col[key] = align_col(subcolmn, just=aligns.get(key, &#34;&gt;&#34;))
                        else:
                            del col[key]
                    col = [templ.format(**row) for row in transps(col)]
                else:
                    col = align_col([statkey] + col[&#34;val&#34;])
                return col

            def super_header(col_coord, idx, col):
                header, matter = col[0], col[1:]
                cc = col_coord.repr2(not idx, str).strip(&#34;()&#34;).replace(&#34;, &#34;, &#34;,&#34;)
                cc = cc.center(len(header), &#34;_&#34;)  # +1 width for wide chars like ✔️
                return [cc + &#34;\n&#34; + header] + matter

            # Transpose
            columns = [list(x) for x in zip(*rows)]

            # Format column
            for j, (col_coord, column) in enumerate(zip(cc, columns)):
                col = align(column)
                if h2:
                    col = super_header(col_coord, j, col)
                columns[j] = col

            # Un-transpose
            rows = [list(x) for x in zip(*columns)]

            return rows

        dims, tables = self.table_tree(statkey, dims, costfun=costfun)

        for table_coord, table in tables.items():

            # Get table&#39;s column coords/ticks (cc).
            # cc is really a set, but we use dict for ordering.
            # cc = self.ticks[dims[&#34;inner&#34;]]  # may be &gt; needed
            # cc = table[0].keys()            # may be &lt; needed
            cc = {c: None for row in table.values() for c in row}
            # Could additionally do cc = table.squeeze() but is it worth it?

            # Convert table (rows) into rows (lists) of equal length
            rows = [[row.get(c, None) for c in cc] for row in table.values()]

            # Align cols
            h2 = &#34;\n&#34; if len(cc) &gt; 1 else &#34;&#34;  # super-header?
            headers, *rows = make_cols(rows, cc, subcols, h2)

            # Prepend left-side (attr) table
            if squeeze_labels:
                table = table.squeeze()
            headers = [h2+k for k in table.dims] + [h2+&#39;⑊&#39;] + headers
            for i, (key, row) in enumerate(zip(table, rows)):
                rows[i] = [*key] + [&#39;|&#39;] + row

            print()
            if dims[&#39;outer&#39;]:
                # Title
                table_title = &#34;Table for &#34; + table_coord.repr2(True).strip(&#34;()&#34;)
                if colorize:
                    clrs = colorama.Back.YELLOW, colorama.Fore.BLACK
                    table_title = color_text(table_title, *clrs)
                print(table_title)
            table = tabulate(rows, headers).replace(&#39;␣&#39;, &#39; &#39;)
            if colorize:
                table = stripe(table, slice(2, None))
            print(table)

        return tables

    def plot(self, statkey, dims, get_style=default_styles,
             fignum=None, figsize=None, panels=None, costfun=None,
             title1=None, title2=None, unique_labels=True, squeeze_labels=True):
        &#34;&#34;&#34;Plot (tables of) results.

        Analagously to `xpSpace.print`,
        the averages are grouped by `dims[&#34;inner&#34;]`,
        which here plays the role of the x-axis.

        The averages can also be grouped by `dims[&#34;outer&#34;]`,
        producing a figure with multiple (columns of) panels.

        The optimal points/parameters/attributes are plotted in smaller panels
        below the main plot. This can be turned off by providing the figure
        dims through the `panels` argument.

        The parameters `statkey`, `dims`, `costfun`, `sqeeze_labels`
        are documented in `xpSpace.print`.

        Parameters
        ----------
        get_style: function
            A function that takes an object, and returns a dict of line styles,
            usually as a function of the object&#39;s attributes.
        title1: anything
            Figure title (in addition to the the defaults).
        title2: anything
            Figure title (in addition to the defaults). Goes on a new line.
        unique_labels: bool
            Only show a given line label once, even if it appears in several panels.
        squeeze_labels:
            Don&#39;t include redundant attributes in the labels.
        &#34;&#34;&#34;
        def plot1(panelcol, row, style):
            &#34;&#34;&#34;Plot a given line (row) in the main panel and the optim panels.

            Involves: Sort, insert None&#39;s, handle constant lines.
            &#34;&#34;&#34;
            # Make a full row (yy) of vals, whether is_constant or not.
            # is_constant = (len(row)==1 and next(iter(row))==row.Coord(None))
            is_constant = all(x == row.Coord(None) for x in row)
            if is_constant:
                yy = [row[None, ] for _ in xticks]
                style.marker = None
            else:
                yy = [row.get(row.Coord(x), None) for x in xticks]

            # Plot main
            row.vals = [getattr(y, &#39;val&#39;, None) for y in yy]
            row.handles = {}
            row.handles[&#34;main_panel&#34;] = panelcol[0].plot(xticks, row.vals, **style)[0]

            # Plot tuning params
            row.tuned_coords = {}  # Store ordered, &#34;transposed&#34; argmins
            argmins = [getattr(y, &#39;tuned_coord&#39;, None) for y in yy]
            for a, panel in zip(dims[&#34;optim&#34;], panelcol[1:]):
                yy = [getattr(coord, a, None) for coord in argmins]
                row.tuned_coords[a] = yy

                # Plotting all None&#39;s sets axes units (like any plotting call)
                # which can cause trouble if the axes units were actually supposed
                # to be categorical (eg upd_a), but this is only revealed later.
                if not all(y == None for y in yy):
                    row.handles[a] = panel.plot(xticks, yy, **style)

        def label_management(table):
            def pruner(style):
                label = style.get(&#34;label&#34;, None)
                if unique_labels:
                    if label in register:
                        del style[&#34;label&#34;]
                    elif label:
                        register.add(style[&#34;label&#34;])
                        pruner.has_labels = True
                elif label:
                    pruner.has_labels = True
            pruner.has_labels = False

            def squeezer(coord):
                return intersect(coord._asdict(), label_attrs)
            if squeeze_labels:
                label_attrs = xpList(table.keys()).prep_table()[0]
            else:
                label_attrs = table.dims

            return pruner, squeezer
        register = set()

        def beautify(panels, title, has_labels):
            panel0 = panels[0]
            # panel0.set_title(title)
            panel0.text(.5, 1, title, fontsize=12, ha=&#34;center&#34;, va=&#34;bottom&#34;,
                        transform=panel0.transAxes, bbox=dict(
                            facecolor=&#39;lightyellow&#39;, edgecolor=&#39;k&#39;,
                            alpha=0.99, boxstyle=&#34;round,pad=0.25&#34;,
                            # NB: padding makes label spill into axes
                        ))
            if has_labels:
                panel0.legend()
            if panel0.is_first_col():
                panel0.set_ylabel(statkey)
            panels[-1].set_xlabel(dims[&#34;inner&#34;][0])
            # Tuning panels:
            for a, panel in zip(dims[&#34;optim&#34;] or (), panels[1:]):
                if panel.is_first_col():
                    panel.set_ylabel(f&#34;Optim.\n{a}&#34;)

        # Nest dims through table_tree()
        assert len(dims[&#34;inner&#34;]) == 1, &#34;You must chose the abscissa.&#34;
        dims, tables = self.table_tree(statkey, dims, costfun=costfun)

        if not hasattr(self, &#34;ticks&#34;):
            # TODO 6: this is probationary.
            # In case self is actually a subspace, it may be that it does not contain
            # all of the ticks of the original xpSpace. This may be fine,
            # and we generate the ticks here again. However, this is costly-ish, so you
            # should maybe simply (manually) assign them from the original xpSpace.
            # And maybe you actually want the plotted lines to have holes where self
            # has no values. Changes in the ticks are not obvious to the naked eye,
            # unlike the case for printed tables (where column changes are quite clear).
            print(color_text(&#34;Warning:&#34;, colorama.Fore.RED), &#34;Making new x-ticks.&#34;
                  &#34;\nConsider assigning them yourself from the original&#34;
                  &#34; xpSpace to this subspace.&#34;)
            self.make_ticks(xpList(self).prep_table()[0])
        xticks = self.tickz(dims[&#34;inner&#34;][0])

        # Create figure axes
        if panels is None:
            nrows   = len(dims[&#39;optim&#39;] or ()) + 1
            ncols   = len(tables)
            maxW    = 12.7  # my mac screen
            figsize = figsize or (min(5*ncols, maxW), 7)
            gs      = dict(
                height_ratios=[6]+[1]*(nrows-1),
                hspace=0.05, wspace=0.05,
                # eyeballed:
                left=0.15/(1+np.log(ncols)),
                right=0.97, bottom=0.06, top=0.9)
            # Create
            _, panels = place.freshfig(num=fignum, figsize=figsize,
                                       nrows=nrows, sharex=True,
                                       ncols=ncols, sharey=&#39;row&#39;,
                                       gridspec_kw=gs, squeeze=False)
        else:
            panels = np.atleast_2d(panels)

        # Fig. Title
        fig = panels[0, 0].figure
        fig_title = &#34;Averages wrt. time&#34;
        if dims[&#34;mean&#34;] is not None:
            fig_title += &#34; and &#34; + &#34;, &#34;.join([repr(c) for c in dims[&#39;mean&#39;]])
        if title1 is not None:
            fig_title += &#34;. &#34; + title1
        if title2 is not None:
            with nonchalance():
                title2 = title2.relative_to(rc.dirs[&#34;data&#34;])
            fig_title += &#34;\n&#34; + str(title2)
        fig.suptitle(fig_title)

        # Loop outer
        for ax_column, (table_coord, table) in zip(panels.T, tables.items()):
            table.panels = ax_column
            label_prune, label_squeeze = label_management(table)
            for coord, row in table.items():
                style = get_style(NoneDict(label_squeeze(coord)))
                label_prune(style)
                plot1(table.panels, row, style)

            beautify(table.panels,
                     title=(&#34;&#34; if dims[&#34;outer&#34;] is None else
                            table_coord.repr2(True).strip(&#34;()&#34;)),
                     has_labels=label_prune.has_labels)

        tables.fig = fig  # add reference to fig
        return tables</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dapper.xp_process.SparseSpace" href="#dapper.xp_process.SparseSpace">SparseSpace</a></li>
<li>builtins.dict</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dapper.xp_process.xpSpace.from_list"><code class="name flex">
<span>def <span class="ident">from_list</span></span>(<span>xps, tick_ordering=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Init. from a list of objects, typically experiments referred to as <code>xp</code>s.</p>
<ul>
<li>Computes the relevant <code>dims</code> from the attributes, and</li>
<li>Fills the dict by <code>xp</code>s.</li>
<li>Computes and writes the attribute <code>ticks</code>.</li>
</ul>
<p>This creates a <code><a title="dapper.xp_process.SparseSpace" href="#dapper.xp_process.SparseSpace">SparseSpace</a></code> of <code>xp</code>s. However, the nested subspaces generated
by <code><a title="dapper.xp_process.xpSpace.table_tree" href="#dapper.xp_process.xpSpace.table_tree">xpSpace.table_tree()</a></code> (for printing and plotting) will hold objects of type
<code>UncertainQtty</code>, because it calls <code>mean</code> which calls <code>get_stat(statkey)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L310-L327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def from_list(cls, xps, tick_ordering=None):
    &#34;&#34;&#34;Init. from a list of objects, typically experiments referred to as `xp`s.

    - Computes the relevant `dims` from the attributes, and
    - Fills the dict by `xp`s.
    - Computes and writes the attribute `ticks`.

    This creates a `SparseSpace` of `xp`s. However, the nested subspaces generated
    by `xpSpace.table_tree` (for printing and plotting) will hold objects of type
    `UncertainQtty`, because it calls `mean` which calls `get_stat(statkey)`.
    &#34;&#34;&#34;
    # Define and fill SparseSpace
    dct = xpList(xps).prep_table(nomerge=[&#39;xSect&#39;])[0]
    self = cls(dct.keys())
    self.fill(xps)
    self.make_ticks(dct, tick_ordering)
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.xp_process.xpSpace.make_ticks"><code class="name flex">
<span>def <span class="ident">make_ticks</span></span>(<span>self, dct, ordering=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unique &amp; sort, for each individual "dim" in <code>dct</code>. Assign to <code>self.ticks</code>.</p>
<p>NB: <code>self.ticks</code> will not "propagate" through <code><a title="dapper.xp_process.SparseSpace.nest" href="#dapper.xp_process.SparseSpace.nest">SparseSpace.nest()</a></code> or the like.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L329-L359" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make_ticks(self, dct, ordering=None):
    &#34;&#34;&#34;Unique &amp; sort, for each individual &#34;dim&#34; in `dct`. Assign to `self.ticks`.

    NB: `self.ticks` will not &#34;propagate&#34; through `SparseSpace.nest` or the like.
    &#34;&#34;&#34;
    self.ticks = dct
    ordering = ordering or {}
    for name, values in dct.items():
        ticks = set(values)  # unique (jumbles order)
        order = ordering.get(name, &#39;as-found&#39;)

        # Sort key
        if callable(order):
            key = order
        elif &#39;as-found&#39; in order:
            key = values.index
        else:  # &#34;natural&#34;
            def key(x):
                return x

        # Place None&#39;s at the end
        def key_safe(x):
            return (x is None), key(x)

        # Sort
        ticks = sorted(ticks, key=key_safe)
        # Reverse
        if isinstance(order, str) and &#34;rev&#34; in order:
            ticks = ticks[::-1]
        # Assign
        dct[name] = ticks</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self, xps)</span>
</code></dt>
<dd>
<div class="desc"><p>Mass insertion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L361-L363" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fill(self, xps):
    &#34;&#34;&#34;Mass insertion.&#34;&#34;&#34;
    self.update([(self.coord_from_attrs(xp), xp) for xp in xps])</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.squeeze"><code class="name flex">
<span>def <span class="ident">squeeze</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Eliminate unnecessary dimensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L365-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def squeeze(self):
    &#34;&#34;&#34;Eliminate unnecessary dimensions.&#34;&#34;&#34;
    squeezed = xpSpace(xpList(self).prep_table()[0])
    squeezed.fill(self)
    return squeezed</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.get_stat"><code class="name flex">
<span>def <span class="ident">get_stat</span></span>(<span>self, statkey='rmse.a')</span>
</code></dt>
<dd>
<div class="desc"><p>Make <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code> with same <code>Coord</code> as <code>self</code>, but values <code>xp.avrgs.statkey</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L371-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_stat(self, statkey=&#34;rmse.a&#34;):
    &#34;&#34;&#34;Make `xpSpace` with same `Coord` as `self`, but values `xp.avrgs.statkey`.&#34;&#34;&#34;
    # Init a new xpDict to hold stat
    avrgs = self.__class__(self.dims)

    found_anything = False
    for coord, xp in self.items():
        val = getattr(xp.avrgs, statkey, None)
        avrgs[coord] = val
        found_anything = found_anything or (val is not None)

    if not found_anything:
        raise AttributeError(
            f&#34;The stat.&#39;{statkey}&#39; was not found among any of the xp&#39;s.&#34;)

    return avrgs</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self, dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute mean over <code>dims</code> (a list). Returns <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code> without those <code>dims</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L388-L417" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mean(self, dims=None):
    &#34;&#34;&#34;Compute mean over `dims` (a list). Returns `xpSpace` without those `dims`.&#34;&#34;&#34;
    # Note: The case `dims=()` should work w/o special treatment.
    if dims is None:
        return self

    nested = self.nest(dims)
    for coord, space in nested.items():

        def getval(uq):
            return uq.val if isinstance(uq, UncertainQtty) else uq
        vals = [getval(uq) for uq in space.values()]

        # Don&#39;t use nanmean! It would give false impressions.
        mu = np.mean(vals)

        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;, category=RuntimeWarning)
            # Don&#39;t print warnings caused by N=1.
            # It already correctly yield nan&#39;s.
            var = np.var(vals, ddof=1)

        N = len(vals)
        uq = UncertainQtty(mu, np.sqrt(var/N))
        uq.nTotal   = N
        uq.nFail    = N - np.isfinite(vals).sum()
        uq.nSuccess = N - uq.nFail

        nested[coord] = uq
    return nested</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.tune"><code class="name flex">
<span>def <span class="ident">tune</span></span>(<span>self, dims=None, costfun=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get (compile/tabulate) a stat. optimised wrt. tuning params (<code>dims</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L419-L454" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tune(self, dims=None, costfun=None):
    &#34;&#34;&#34;Get (compile/tabulate) a stat. optimised wrt. tuning params (`dims`).&#34;&#34;&#34;
    # Define cost-function
    costfun = (costfun or &#39;increasing&#39;).lower()
    if &#39;increas&#39; in costfun:
        costfun = (lambda x: +x)
    elif &#39;decreas&#39; in costfun:
        costfun = (lambda x: -x)
    else:
        assert callable(costfun)  # custom

    # Note: The case `dims=()` should work w/o special treatment.
    if dims is None:
        return self

    nested = self.nest(dims)
    for coord, space in nested.items():
        # Find optimal value (and coord) within space
        MIN = np.inf
        found_any = False
        for inner_coord, uq in space.items():
            cost = costfun(uq.val)
            if cost &lt;= MIN:
                found_any          = True
                MIN                = cost
                uq_opt             = uq
                uq_opt.tuned_coord = inner_coord

        if not found_any:
            uq_opt = uq  # one is as good as another
            nDim = range(len(space.Coord._fields))
            uq_opt.tuned_coord = space.Coord(*(None for _ in nDim))

        nested[coord] = uq_opt

    return nested</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.validate_dims"><code class="name flex">
<span>def <span class="ident">validate_dims</span></span>(<span>self, dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate dims.</p>
<p>Note: This does not convert None to (), allowing None to remain special.
Use <code>()</code> if tuples are required.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L456-L486" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def validate_dims(self, dims):
    &#34;&#34;&#34;Validate dims.

    Note: This does not convert None to (), allowing None to remain special.
          Use `()` if tuples are required.
    &#34;&#34;&#34;
    roles = {}  # &#34;inv&#34;
    for role in set(dims) | set(DIM_ROLES):
        assert role in DIM_ROLES, f&#34;Invalid role {role!r}&#34;
        dd = dims.get(role, DIM_ROLES[role])

        if dd is None:
            pass  # Purposely special
        else:
            # Ensure iterable
            if isinstance(dd, str) or not hasattr(dd, &#34;__iter__&#34;):
                dd = (dd,)

            dd = self.intersect_dims(dd)

            for dim in dd:

                # Ensure unique
                if dim in roles:
                    raise TypeError(
                        f&#34;A dim (here {dim!r}) cannot be assigned to 2&#34;
                        f&#34; roles (here {role!r} and {roles[dim]!r}).&#34;)
                else:
                    roles[dim] = role
        dims[role] = dd
    return dims</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.table_tree"><code class="name flex">
<span>def <span class="ident">table_tree</span></span>(<span>self, statkey, dims, *, costfun=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make hierarchy <code>outer &gt; inner &gt; mean &gt; optim</code> using <code><a title="dapper.xp_process.SparseSpace.nest" href="#dapper.xp_process.SparseSpace.nest">SparseSpace.nest()</a></code>.</p>
<p>The dimension passed to <code>nest</code> (at each level) is specified by <code>dims</code>.
The dimensions of <code>dims['mean']</code> and <code>dims['optim']</code> get eliminated
by the mean/tune operations. The <code>dims['outer']</code> and `dims['inner']
become the keys for the output hierarchy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>cannot support multiple <code>statkey</code>s because it's not (obviously) meaningful
when optimizing over <code>dims['optim']</code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L488-L549" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def table_tree(self, statkey, dims, *, costfun=None):
    &#34;&#34;&#34;Make hierarchy `outer &gt; inner &gt; mean &gt; optim` using `SparseSpace.nest`.

    The dimension passed to `nest` (at each level) is specified by `dims`.
    The dimensions of `dims[&#39;mean&#39;]` and `dims[&#39;optim&#39;]` get eliminated
    by the mean/tune operations. The `dims[&#39;outer&#39;]` and `dims[&#39;inner&#39;]
    become the keys for the output hierarchy.

    .. note::
        cannot support multiple `statkey`s because it&#39;s not (obviously) meaningful
        when optimizing over `dims[&#39;optim&#39;]`.
    &#34;&#34;&#34;
    dims = self.validate_dims(dims)

    def mean_tune(xp_dict):
        &#34;&#34;&#34;Take mean, then tune.

        Note: the `SparseSpace` implementation should be sufficiently
        &#34;uncluttered&#34; that `mean_tune` (or a few of its code lines)
        could be called anywhere above/between/below
        the `nest`ing of `outer` or `inner`.
        These possibile call locations are commented in the code.
        &#34;&#34;&#34;
        uq_dict = xp_dict.get_stat(statkey)
        uq_dict = uq_dict.mean(dims[&#39;mean&#39;])
        uq_dict = uq_dict.tune(dims[&#39;optim&#39;], costfun)
        return uq_dict

    self2 = mean_tune(self)
    # Prefer calling mean_tune() [also see its docstring]
    # before doing outer/inner nesting. This is because then the dims of
    # a row (xpSpace) should not include mean&amp;optim, and thus:
    #  - Column header/coords may be had directly as row.keys(),
    #    without extraction by coord_from_attrs() from (e.g.) row[0].
    #  - Don&#39;t need to propagate mean&amp;optim dims down to the row level.
    #    which would require defining rows by the nesting:
    #    rows = table.nest(outer_dims=complement(table.dims,
    #        *(dims[&#39;inner&#39;] or ()),
    #        *(dims[&#39;mean&#39;]  or ()),
    #        *(dims[&#39;optim&#39;] or ()) ))
    #  - Each level of the output from table_tree
    #    is a smaller (and more manageable) dict.

    tables = self2.nest(outer_dims=dims[&#39;outer&#39;])
    for table_coord, table in tables.items():
        # table = mean_tune(table)

        # Should not be used (nesting as rows is more natural,
        # and is required for getting distinct/row_keys).
        # cols = table.nest(outer_dims=dims[&#39;inner&#39;])

        rows = table.nest(inner_dims=dims[&#39;inner&#39;] or ())

        # Overwrite table by its nesting as rows
        tables[table_coord] = rows

        # for row_coord, row in rows.items():
        # rows[row_coord] = mean_tune(row)

    args = dict(statkey=statkey, xp_dict=self, dims=dims)
    tables.created_with = args
    return dims, tables</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.tickz"><code class="name flex">
<span>def <span class="ident">tickz</span></span>(<span>self, dim_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Dimension (axis) ticks without None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L551-L553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tickz(self, dim_name):
    &#34;&#34;&#34;Dimension (axis) ticks without None&#34;&#34;&#34;
    return [x for x in self.ticks[dim_name] if x is not None]</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, statkey, dims, subcols=True, decimals=None, costfun=None, squeeze_labels=True, colorize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Print tables of results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>statkey</code></strong> :&ensp;<code>str</code></dt>
<dd>The statistic to extract from the <code>xp.avrgs</code> for each <code>xp</code>.</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Allots (maps) the dims of <code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code> to different roles in the tables.</p>
<ul>
<li>The "role" <code>outer</code> should list the dims/attributes
used to define the splitting of the results into <em>separate tables</em>:
one table for each distinct combination of attributes.</li>
<li>Similarly , the role <code>inner</code> determines which attributes
split a table into its columns.</li>
<li><code>mean</code> lists the attributes over which the mean is taken
(for that row &amp; column)</li>
<li><code>optim</code> lists the attributes used over which the optimum
is searched for (after taking the mean).</li>
</ul>
<p>Example:</p>
<pre><code>dict(outer='da_method', inner='N', mean='seed',
     optim=('infl','loc_rad'))
</code></pre>
<p>Equivalently, use <code>mean=("seed",)</code>.
It is acceptible to leave this empty: <code>mean=()</code> or <code>mean=None</code>.</p>
</dd>
<dt><strong><code>subcols</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>If <code>True</code>, then subcolumns are added to indicate</p>
<ul>
<li><code>1σ</code>: the confidence interval. If <code>mean=None</code> is used, this simply reports
the value <code>.prec</code> of the <code>statkey</code>, providing this is an <code>UncertainQtty</code>.
Otherwise, it is computed as <code>sqrt(var(xps)/N)</code>,
where <code>xps</code> is the set of statistic gathered over the <code>mean</code> dimensions.</li>
<li><code>*(optim)</code>: the optimal point (among all <code>optim</code> attributes),
as defined by <code>costfun</code>.</li>
<li><code>☠</code>: the number of failures (non-finite values) at that point.</li>
<li><code>✓</code>: the number of successes that go into the value</li>
</ul>
</dd>
<dt><strong><code>decimals</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of decimals to print.
If <code>None</code>, this is determined for each statistic by its uncertainty.</dd>
<dt><strong><code>costfun</code></strong> :&ensp;<code>str</code> or <code>function</code></dt>
<dd>Use <code>'increasing'</code> (default) or <code>'decreasing'</code> to indicate that the optimum
is defined as the lowest or highest value of the <code>statkey</code> found.</dd>
<dt><strong><code>squeeze_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Don't include redundant attributes in the line labels.
Caution: <code>get_style</code> will not be able to access the eliminated attrs.</dd>
<dt><strong><code>colorize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Add color to tables for readability.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L555-L699" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print(self, statkey, dims,  # noqa (shadowing builtin)
          subcols=True, decimals=None, costfun=None,
          squeeze_labels=True, colorize=True):
    &#34;&#34;&#34;Print tables of results.

    Parameters
    ----------
    statkey: str
        The statistic to extract from the `xp.avrgs` for each `xp`.
    dims: dict
        Allots (maps) the dims of `xpSpace` to different roles in the tables.

        - The &#34;role&#34; `outer` should list the dims/attributes
          used to define the splitting of the results into *separate tables*:
          one table for each distinct combination of attributes.
        - Similarly , the role `inner` determines which attributes
          split a table into its columns.
        - `mean` lists the attributes over which the mean is taken
          (for that row &amp; column)
        - `optim` lists the attributes used over which the optimum
           is searched for (after taking the mean).

        Example:

            dict(outer=&#39;da_method&#39;, inner=&#39;N&#39;, mean=&#39;seed&#39;,
                 optim=(&#39;infl&#39;,&#39;loc_rad&#39;))

        Equivalently, use `mean=(&#34;seed&#34;,)`.
        It is acceptible to leave this empty: `mean=()` or `mean=None`.
    subcols: bool
        If `True`, then subcolumns are added to indicate

        - `1σ`: the confidence interval. If `mean=None` is used, this simply reports
          the value `.prec` of the `statkey`, providing this is an `UncertainQtty`.
          Otherwise, it is computed as `sqrt(var(xps)/N)`,
          where `xps` is the set of statistic gathered over the `mean` dimensions.
        - `*(optim)`: the optimal point (among all `optim` attributes),
          as defined by `costfun`.
        - `☠`: the number of failures (non-finite values) at that point.
        - `✓`: the number of successes that go into the value
    decimals: int
        Number of decimals to print.
        If `None`, this is determined for each statistic by its uncertainty.
    costfun: str or function
        Use `&#39;increasing&#39;` (default) or `&#39;decreasing&#39;` to indicate that the optimum
        is defined as the lowest or highest value of the `statkey` found.
    squeeze_labels: bool
        Don&#39;t include redundant attributes in the line labels.
        Caution: `get_style` will not be able to access the eliminated attrs.
    colorize: bool
        Add color to tables for readability.
    &#34;&#34;&#34;
    # Inform dims[&#34;mean&#34;]
    if dims.get(&#39;mean&#39;, None):
        print(f&#34;Averages (in time and) over {dims[&#39;mean&#39;]}.&#34;)
    else:
        print(&#34;Averages in time only&#34;
              &#34; (=&gt; the 1σ estimates may be unreliable).&#34;)

    def make_cols(rows, cc, subcols, h2):
        &#34;&#34;&#34;Subcolumns: align, justify, join.&#34;&#34;&#34;
        # Define subcol formats
        if subcols:
            templ = &#34;{val} ±{prec}&#34;
            templ += &#34;&#34; if dims[&#39;optim&#39;] is None else &#34; *{tuned_coord}&#34;
            templ += &#34;&#34; if  dims[&#39;mean&#39;] is None else &#34; {nFail} {nSuccess}&#34;  # noqa
            aligns = dict(prec=&#34;&lt;&#34;, tuned_coord=&#34;&lt;&#34;)
            labels = dict(val=statkey, prec=&#34;1σ&#34;,
                          tuned_coord=dims[&#34;optim&#34;],
                          nFail=&#34;☠&#34;, nSuccess=&#34;✓&#34;)

        def align(column):
            col = unpack_uqs(column, decimals)
            if subcols:
                for key in list(col):
                    if key in templ:
                        subcolmn = [labels.get(key, key)] + col[key]
                        col[key] = align_col(subcolmn, just=aligns.get(key, &#34;&gt;&#34;))
                    else:
                        del col[key]
                col = [templ.format(**row) for row in transps(col)]
            else:
                col = align_col([statkey] + col[&#34;val&#34;])
            return col

        def super_header(col_coord, idx, col):
            header, matter = col[0], col[1:]
            cc = col_coord.repr2(not idx, str).strip(&#34;()&#34;).replace(&#34;, &#34;, &#34;,&#34;)
            cc = cc.center(len(header), &#34;_&#34;)  # +1 width for wide chars like ✔️
            return [cc + &#34;\n&#34; + header] + matter

        # Transpose
        columns = [list(x) for x in zip(*rows)]

        # Format column
        for j, (col_coord, column) in enumerate(zip(cc, columns)):
            col = align(column)
            if h2:
                col = super_header(col_coord, j, col)
            columns[j] = col

        # Un-transpose
        rows = [list(x) for x in zip(*columns)]

        return rows

    dims, tables = self.table_tree(statkey, dims, costfun=costfun)

    for table_coord, table in tables.items():

        # Get table&#39;s column coords/ticks (cc).
        # cc is really a set, but we use dict for ordering.
        # cc = self.ticks[dims[&#34;inner&#34;]]  # may be &gt; needed
        # cc = table[0].keys()            # may be &lt; needed
        cc = {c: None for row in table.values() for c in row}
        # Could additionally do cc = table.squeeze() but is it worth it?

        # Convert table (rows) into rows (lists) of equal length
        rows = [[row.get(c, None) for c in cc] for row in table.values()]

        # Align cols
        h2 = &#34;\n&#34; if len(cc) &gt; 1 else &#34;&#34;  # super-header?
        headers, *rows = make_cols(rows, cc, subcols, h2)

        # Prepend left-side (attr) table
        if squeeze_labels:
            table = table.squeeze()
        headers = [h2+k for k in table.dims] + [h2+&#39;⑊&#39;] + headers
        for i, (key, row) in enumerate(zip(table, rows)):
            rows[i] = [*key] + [&#39;|&#39;] + row

        print()
        if dims[&#39;outer&#39;]:
            # Title
            table_title = &#34;Table for &#34; + table_coord.repr2(True).strip(&#34;()&#34;)
            if colorize:
                clrs = colorama.Back.YELLOW, colorama.Fore.BLACK
                table_title = color_text(table_title, *clrs)
            print(table_title)
        table = tabulate(rows, headers).replace(&#39;␣&#39;, &#39; &#39;)
        if colorize:
            table = stripe(table, slice(2, None))
        print(table)

    return tables</code></pre>
</details>
</dd>
<dt id="dapper.xp_process.xpSpace.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, statkey, dims, get_style=&lt;function default_styles&gt;, fignum=None, figsize=None, panels=None, costfun=None, title1=None, title2=None, unique_labels=True, squeeze_labels=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot (tables of) results.</p>
<p>Analagously to <code><a title="dapper.xp_process.xpSpace.print" href="#dapper.xp_process.xpSpace.print">xpSpace.print()</a></code>,
the averages are grouped by <code>dims["inner"]</code>,
which here plays the role of the x-axis.</p>
<p>The averages can also be grouped by <code>dims["outer"]</code>,
producing a figure with multiple (columns of) panels.</p>
<p>The optimal points/parameters/attributes are plotted in smaller panels
below the main plot. This can be turned off by providing the figure
dims through the <code>panels</code> argument.</p>
<p>The parameters <code>statkey</code>, <code>dims</code>, <code>costfun</code>, <code>sqeeze_labels</code>
are documented in <code><a title="dapper.xp_process.xpSpace.print" href="#dapper.xp_process.xpSpace.print">xpSpace.print()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>get_style</code></strong> :&ensp;<code>function</code></dt>
<dd>A function that takes an object, and returns a dict of line styles,
usually as a function of the object's attributes.</dd>
<dt><strong><code>title1</code></strong> :&ensp;<code>anything</code></dt>
<dd>Figure title (in addition to the the defaults).</dd>
<dt><strong><code>title2</code></strong> :&ensp;<code>anything</code></dt>
<dd>Figure title (in addition to the defaults). Goes on a new line.</dd>
<dt><strong><code>unique_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only show a given line label once, even if it appears in several panels.</dd>
</dl>
<p>squeeze_labels:
Don't include redundant attributes in the labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/xp_process.py#L701-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self, statkey, dims, get_style=default_styles,
         fignum=None, figsize=None, panels=None, costfun=None,
         title1=None, title2=None, unique_labels=True, squeeze_labels=True):
    &#34;&#34;&#34;Plot (tables of) results.

    Analagously to `xpSpace.print`,
    the averages are grouped by `dims[&#34;inner&#34;]`,
    which here plays the role of the x-axis.

    The averages can also be grouped by `dims[&#34;outer&#34;]`,
    producing a figure with multiple (columns of) panels.

    The optimal points/parameters/attributes are plotted in smaller panels
    below the main plot. This can be turned off by providing the figure
    dims through the `panels` argument.

    The parameters `statkey`, `dims`, `costfun`, `sqeeze_labels`
    are documented in `xpSpace.print`.

    Parameters
    ----------
    get_style: function
        A function that takes an object, and returns a dict of line styles,
        usually as a function of the object&#39;s attributes.
    title1: anything
        Figure title (in addition to the the defaults).
    title2: anything
        Figure title (in addition to the defaults). Goes on a new line.
    unique_labels: bool
        Only show a given line label once, even if it appears in several panels.
    squeeze_labels:
        Don&#39;t include redundant attributes in the labels.
    &#34;&#34;&#34;
    def plot1(panelcol, row, style):
        &#34;&#34;&#34;Plot a given line (row) in the main panel and the optim panels.

        Involves: Sort, insert None&#39;s, handle constant lines.
        &#34;&#34;&#34;
        # Make a full row (yy) of vals, whether is_constant or not.
        # is_constant = (len(row)==1 and next(iter(row))==row.Coord(None))
        is_constant = all(x == row.Coord(None) for x in row)
        if is_constant:
            yy = [row[None, ] for _ in xticks]
            style.marker = None
        else:
            yy = [row.get(row.Coord(x), None) for x in xticks]

        # Plot main
        row.vals = [getattr(y, &#39;val&#39;, None) for y in yy]
        row.handles = {}
        row.handles[&#34;main_panel&#34;] = panelcol[0].plot(xticks, row.vals, **style)[0]

        # Plot tuning params
        row.tuned_coords = {}  # Store ordered, &#34;transposed&#34; argmins
        argmins = [getattr(y, &#39;tuned_coord&#39;, None) for y in yy]
        for a, panel in zip(dims[&#34;optim&#34;], panelcol[1:]):
            yy = [getattr(coord, a, None) for coord in argmins]
            row.tuned_coords[a] = yy

            # Plotting all None&#39;s sets axes units (like any plotting call)
            # which can cause trouble if the axes units were actually supposed
            # to be categorical (eg upd_a), but this is only revealed later.
            if not all(y == None for y in yy):
                row.handles[a] = panel.plot(xticks, yy, **style)

    def label_management(table):
        def pruner(style):
            label = style.get(&#34;label&#34;, None)
            if unique_labels:
                if label in register:
                    del style[&#34;label&#34;]
                elif label:
                    register.add(style[&#34;label&#34;])
                    pruner.has_labels = True
            elif label:
                pruner.has_labels = True
        pruner.has_labels = False

        def squeezer(coord):
            return intersect(coord._asdict(), label_attrs)
        if squeeze_labels:
            label_attrs = xpList(table.keys()).prep_table()[0]
        else:
            label_attrs = table.dims

        return pruner, squeezer
    register = set()

    def beautify(panels, title, has_labels):
        panel0 = panels[0]
        # panel0.set_title(title)
        panel0.text(.5, 1, title, fontsize=12, ha=&#34;center&#34;, va=&#34;bottom&#34;,
                    transform=panel0.transAxes, bbox=dict(
                        facecolor=&#39;lightyellow&#39;, edgecolor=&#39;k&#39;,
                        alpha=0.99, boxstyle=&#34;round,pad=0.25&#34;,
                        # NB: padding makes label spill into axes
                    ))
        if has_labels:
            panel0.legend()
        if panel0.is_first_col():
            panel0.set_ylabel(statkey)
        panels[-1].set_xlabel(dims[&#34;inner&#34;][0])
        # Tuning panels:
        for a, panel in zip(dims[&#34;optim&#34;] or (), panels[1:]):
            if panel.is_first_col():
                panel.set_ylabel(f&#34;Optim.\n{a}&#34;)

    # Nest dims through table_tree()
    assert len(dims[&#34;inner&#34;]) == 1, &#34;You must chose the abscissa.&#34;
    dims, tables = self.table_tree(statkey, dims, costfun=costfun)

    if not hasattr(self, &#34;ticks&#34;):
        # TODO 6: this is probationary.
        # In case self is actually a subspace, it may be that it does not contain
        # all of the ticks of the original xpSpace. This may be fine,
        # and we generate the ticks here again. However, this is costly-ish, so you
        # should maybe simply (manually) assign them from the original xpSpace.
        # And maybe you actually want the plotted lines to have holes where self
        # has no values. Changes in the ticks are not obvious to the naked eye,
        # unlike the case for printed tables (where column changes are quite clear).
        print(color_text(&#34;Warning:&#34;, colorama.Fore.RED), &#34;Making new x-ticks.&#34;
              &#34;\nConsider assigning them yourself from the original&#34;
              &#34; xpSpace to this subspace.&#34;)
        self.make_ticks(xpList(self).prep_table()[0])
    xticks = self.tickz(dims[&#34;inner&#34;][0])

    # Create figure axes
    if panels is None:
        nrows   = len(dims[&#39;optim&#39;] or ()) + 1
        ncols   = len(tables)
        maxW    = 12.7  # my mac screen
        figsize = figsize or (min(5*ncols, maxW), 7)
        gs      = dict(
            height_ratios=[6]+[1]*(nrows-1),
            hspace=0.05, wspace=0.05,
            # eyeballed:
            left=0.15/(1+np.log(ncols)),
            right=0.97, bottom=0.06, top=0.9)
        # Create
        _, panels = place.freshfig(num=fignum, figsize=figsize,
                                   nrows=nrows, sharex=True,
                                   ncols=ncols, sharey=&#39;row&#39;,
                                   gridspec_kw=gs, squeeze=False)
    else:
        panels = np.atleast_2d(panels)

    # Fig. Title
    fig = panels[0, 0].figure
    fig_title = &#34;Averages wrt. time&#34;
    if dims[&#34;mean&#34;] is not None:
        fig_title += &#34; and &#34; + &#34;, &#34;.join([repr(c) for c in dims[&#39;mean&#39;]])
    if title1 is not None:
        fig_title += &#34;. &#34; + title1
    if title2 is not None:
        with nonchalance():
            title2 = title2.relative_to(rc.dirs[&#34;data&#34;])
        fig_title += &#34;\n&#34; + str(title2)
    fig.suptitle(fig_title)

    # Loop outer
    for ax_column, (table_coord, table) in zip(panels.T, tables.items()):
        table.panels = ax_column
        label_prune, label_squeeze = label_management(table)
        for coord, row in table.items():
            style = get_style(NoneDict(label_squeeze(coord)))
            label_prune(style)
            plot1(table.panels, row, style)

        beautify(table.panels,
                 title=(&#34;&#34; if dims[&#34;outer&#34;] is None else
                        table_coord.repr2(True).strip(&#34;()&#34;)),
                 has_labels=label_prune.has_labels)

    tables.fig = fig  # add reference to fig
    return tables</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dapper.xp_process.SparseSpace" href="#dapper.xp_process.SparseSpace">SparseSpace</a></b></code>:
<ul class="hlist">
<li><code><a title="dapper.xp_process.SparseSpace.append_dim" href="#dapper.xp_process.SparseSpace.append_dim">append_dim</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.coord_from_attrs" href="#dapper.xp_process.SparseSpace.coord_from_attrs">coord_from_attrs</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.coords_matching" href="#dapper.xp_process.SparseSpace.coords_matching">coords_matching</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.intersect_dims" href="#dapper.xp_process.SparseSpace.intersect_dims">intersect_dims</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.label_xSection" href="#dapper.xp_process.SparseSpace.label_xSection">label_xSection</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.nest" href="#dapper.xp_process.SparseSpace.nest">nest</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.subspace" href="#dapper.xp_process.SparseSpace.subspace">subspace</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.update" href="#dapper.xp_process.SparseSpace.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="DAPPER" href="https://nansencenter.github.io/DAPPER">
<img src="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo_wtxt.png" alt="">
<!-- can add style="width:200px;" to img -->
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/nansencenter/DAPPER site:nansencenter.github.io/DAPPER"
data-gaCategoryParameter="dapper.xp_process">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dapper" href="index.html">dapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dapper.xp_process.SparseSpace" href="#dapper.xp_process.SparseSpace">SparseSpace</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.xp_process.SparseSpace.update" href="#dapper.xp_process.SparseSpace.update">update</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.subspace" href="#dapper.xp_process.SparseSpace.subspace">subspace</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.coords_matching" href="#dapper.xp_process.SparseSpace.coords_matching">coords_matching</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.coord_from_attrs" href="#dapper.xp_process.SparseSpace.coord_from_attrs">coord_from_attrs</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.nest" href="#dapper.xp_process.SparseSpace.nest">nest</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.intersect_dims" href="#dapper.xp_process.SparseSpace.intersect_dims">intersect_dims</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.append_dim" href="#dapper.xp_process.SparseSpace.append_dim">append_dim</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.label_xSection" href="#dapper.xp_process.SparseSpace.label_xSection">label_xSection</a></code></li>
<li><code><a title="dapper.xp_process.SparseSpace.dims" href="#dapper.xp_process.SparseSpace.dims">dims</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dapper.xp_process.xpSpace" href="#dapper.xp_process.xpSpace">xpSpace</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.xp_process.xpSpace.from_list" href="#dapper.xp_process.xpSpace.from_list">from_list</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.make_ticks" href="#dapper.xp_process.xpSpace.make_ticks">make_ticks</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.fill" href="#dapper.xp_process.xpSpace.fill">fill</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.squeeze" href="#dapper.xp_process.xpSpace.squeeze">squeeze</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.get_stat" href="#dapper.xp_process.xpSpace.get_stat">get_stat</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.mean" href="#dapper.xp_process.xpSpace.mean">mean</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.tune" href="#dapper.xp_process.xpSpace.tune">tune</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.validate_dims" href="#dapper.xp_process.xpSpace.validate_dims">validate_dims</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.table_tree" href="#dapper.xp_process.xpSpace.table_tree">table_tree</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.tickz" href="#dapper.xp_process.xpSpace.tickz">tickz</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.print" href="#dapper.xp_process.xpSpace.print">print</a></code></li>
<li><code><a title="dapper.xp_process.xpSpace.plot" href="#dapper.xp_process.xpSpace.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>